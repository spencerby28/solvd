Directory structure:
└── shopify-shopify_python_api/
    ├── README.md
    ├── CHANGELOG
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── MANIFEST.in
    ├── RELEASING
    ├── SECURITY.md
    ├── dev.yml
    ├── pylintrc
    ├── pyproject.toml
    ├── requirements.txt
    ├── setup.py
    ├── shipit.pypi.yml
    ├── tox.ini
    ├── .pre-commit-config.yaml
    ├── bin/
    │   └── shopify_api.py
    ├── docs/
    │   ├── api-access.md
    │   └── session-tokens.md
    ├── scripts/
    │   └── shopify_api.py
    ├── shopify/
    │   ├── __init__.py
    │   ├── api_access.py
    │   ├── api_version.py
    │   ├── base.py
    │   ├── collection.py
    │   ├── limits.py
    │   ├── mixins.py
    │   ├── session.py
    │   ├── session_token.py
    │   ├── version.py
    │   ├── yamlobjects.py
    │   ├── resources/
    │   │   ├── __init__.py
    │   │   ├── access_scope.py
    │   │   ├── address.py
    │   │   ├── api_permission.py
    │   │   ├── application_charge.py
    │   │   ├── application_credit.py
    │   │   ├── article.py
    │   │   ├── asset.py
    │   │   ├── balance.py
    │   │   ├── billing_address.py
    │   │   ├── blog.py
    │   │   ├── carrier_service.py
    │   │   ├── cart.py
    │   │   ├── checkout.py
    │   │   ├── collect.py
    │   │   ├── collection_listing.py
    │   │   ├── collection_publication.py
    │   │   ├── comment.py
    │   │   ├── country.py
    │   │   ├── currency.py
    │   │   ├── custom_collection.py
    │   │   ├── customer.py
    │   │   ├── customer_group.py
    │   │   ├── customer_invite.py
    │   │   ├── customer_saved_search.py
    │   │   ├── discount_code.py
    │   │   ├── discount_code_creation.py
    │   │   ├── disputes.py
    │   │   ├── draft_order.py
    │   │   ├── draft_order_invoice.py
    │   │   ├── event.py
    │   │   ├── fulfillment.py
    │   │   ├── fulfillment_event.py
    │   │   ├── fulfillment_service.py
    │   │   ├── gift_card.py
    │   │   ├── gift_card_adjustment.py
    │   │   ├── graphql.py
    │   │   ├── image.py
    │   │   ├── inventory_item.py
    │   │   ├── inventory_level.py
    │   │   ├── line_item.py
    │   │   ├── location.py
    │   │   ├── marketing_event.py
    │   │   ├── metafield.py
    │   │   ├── note_attribute.py
    │   │   ├── option.py
    │   │   ├── order.py
    │   │   ├── order_risk.py
    │   │   ├── page.py
    │   │   ├── payment_details.py
    │   │   ├── payouts.py
    │   │   ├── policy.py
    │   │   ├── price_rule.py
    │   │   ├── product.py
    │   │   ├── product_listing.py
    │   │   ├── product_publication.py
    │   │   ├── province.py
    │   │   ├── publication.py
    │   │   ├── receipt.py
    │   │   ├── recurring_application_charge.py
    │   │   ├── redirect.py
    │   │   ├── refund.py
    │   │   ├── report.py
    │   │   ├── resource_feedback.py
    │   │   ├── rule.py
    │   │   ├── script_tag.py
    │   │   ├── shipping_address.py
    │   │   ├── shipping_line.py
    │   │   ├── shipping_zone.py
    │   │   ├── shop.py
    │   │   ├── smart_collection.py
    │   │   ├── storefront_access_token.py
    │   │   ├── tax_line.py
    │   │   ├── tender_transaction.py
    │   │   ├── theme.py
    │   │   ├── transaction.py
    │   │   ├── transactions.py
    │   │   ├── usage_charge.py
    │   │   ├── user.py
    │   │   ├── variant.py
    │   │   └── webhook.py
    │   └── utils/
    │       ├── __init__.py
    │       └── shop_url.py
    ├── test/
    │   ├── __init__.py
    │   ├── access_scope_test.py
    │   ├── api_access_test.py
    │   ├── api_permission_test.py
    │   ├── api_version_test.py
    │   ├── application_credit_test.py
    │   ├── article_test.py
    │   ├── asset_test.py
    │   ├── balance_test.py
    │   ├── base_test.py
    │   ├── blog_test.py
    │   ├── carrier_service_test.py
    │   ├── cart_test.py
    │   ├── checkout_test.py
    │   ├── collection_listing_test.py
    │   ├── collection_publication_test.py
    │   ├── currency_test.py
    │   ├── customer_saved_search_test.py
    │   ├── customer_test.py
    │   ├── discount_code_creation_test.py
    │   ├── discount_code_test.py
    │   ├── disputes_test.py
    │   ├── draft_order_test.py
    │   ├── event_test.py
    │   ├── fulfillment_event_test.py
    │   ├── fulfillment_service_test.py
    │   ├── fulfillment_test.py
    │   ├── gift_card_test.py
    │   ├── graphql_test.py
    │   ├── image_test.py
    │   ├── inventory_item_test.py
    │   ├── inventory_level_test.py
    │   ├── limits_test.py
    │   ├── location_test.py
    │   ├── marketing_event_test.py
    │   ├── order_risk_test.py
    │   ├── order_test.py
    │   ├── pagination_test.py
    │   ├── payouts_test.py
    │   ├── price_rules_test.py
    │   ├── product_listing_test.py
    │   ├── product_publication_test.py
    │   ├── product_test.py
    │   ├── publication_test.py
    │   ├── recurring_charge_test.py
    │   ├── refund_test.py
    │   ├── report_test.py
    │   ├── resource_feedback_test.py
    │   ├── session_test.py
    │   ├── session_token_test.py
    │   ├── shipping_zone_test.py
    │   ├── shop_test.py
    │   ├── storefront_access_token_test.py
    │   ├── tender_transaction_test.py
    │   ├── test_helper.py
    │   ├── transaction_test.py
    │   ├── transactions_test.py
    │   ├── usage_charge_test.py
    │   ├── user_test.py
    │   ├── variant_test.py
    │   ├── fixtures/
    │   │   ├── access_scopes.json
    │   │   ├── application_credit.json
    │   │   ├── application_credits.json
    │   │   ├── article.json
    │   │   ├── articles.json
    │   │   ├── asset.json
    │   │   ├── assets.json
    │   │   ├── authors.json
    │   │   ├── balance.json
    │   │   ├── batch_discount_codes.json
    │   │   ├── blog.json
    │   │   ├── blogs.json
    │   │   ├── carrier_service.json
    │   │   ├── carts.json
    │   │   ├── checkouts.json
    │   │   ├── collection_listing.json
    │   │   ├── collection_listing_product_ids.json
    │   │   ├── collection_listings.json
    │   │   ├── collection_publication.json
    │   │   ├── collection_publications.json
    │   │   ├── currencies.json
    │   │   ├── customer.json
    │   │   ├── customer_invite.json
    │   │   ├── customer_saved_search.json
    │   │   ├── customer_saved_search_customers.json
    │   │   ├── customers_search.json
    │   │   ├── discount_code.json
    │   │   ├── discount_code_creation.json
    │   │   ├── discount_codes.json
    │   │   ├── discount_disabled.json
    │   │   ├── dispute.json
    │   │   ├── disputes.json
    │   │   ├── draft_order.json
    │   │   ├── draft_order_completed.json
    │   │   ├── draft_order_invoice.json
    │   │   ├── draft_orders.json
    │   │   ├── engagement.json
    │   │   ├── events.json
    │   │   ├── fulfillment.json
    │   │   ├── fulfillment_event.json
    │   │   ├── fulfillment_service.json
    │   │   ├── gift_card.json
    │   │   ├── gift_card_adjustment.json
    │   │   ├── gift_card_disabled.json
    │   │   ├── gift_cards.json
    │   │   ├── gift_cards_search.json
    │   │   ├── graphql.json
    │   │   ├── image.json
    │   │   ├── image_metafields.json
    │   │   ├── images.json
    │   │   ├── inventory_item.json
    │   │   ├── inventory_items.json
    │   │   ├── inventory_level.json
    │   │   ├── inventory_levels.json
    │   │   ├── location.json
    │   │   ├── location_inventory_levels.json
    │   │   ├── locations.json
    │   │   ├── marketing_event.json
    │   │   ├── marketing_events.json
    │   │   ├── metafield.json
    │   │   ├── metafields.json
    │   │   ├── metafields_count.json
    │   │   ├── order.json
    │   │   ├── order_risk.json
    │   │   ├── order_risks.json
    │   │   ├── orders.json
    │   │   ├── payout.json
    │   │   ├── payouts.json
    │   │   ├── payouts_transactions.json
    │   │   ├── price_rule.json
    │   │   ├── price_rules.json
    │   │   ├── product.json
    │   │   ├── product_listing.json
    │   │   ├── product_listing_product_ids.json
    │   │   ├── product_listings.json
    │   │   ├── product_publication.json
    │   │   ├── product_publications.json
    │   │   ├── products.json
    │   │   ├── publications.json
    │   │   ├── recurring_application_charge_adjustment.json
    │   │   ├── recurring_application_charges.json
    │   │   ├── recurring_application_charges_no_active.json
    │   │   ├── refund.json
    │   │   ├── refund_calculate.json
    │   │   ├── report.json
    │   │   ├── reports.json
    │   │   ├── shipping_zones.json
    │   │   ├── shop.json
    │   │   ├── storefront_access_token.json
    │   │   ├── storefront_access_tokens.json
    │   │   ├── tags.json
    │   │   ├── tender_transactions.json
    │   │   ├── transaction.json
    │   │   ├── transactions.json
    │   │   ├── usage_charge.json
    │   │   ├── usage_charges.json
    │   │   ├── user.json
    │   │   ├── users.json
    │   │   ├── variant.json
    │   │   └── variants.json
    │   └── utils/
    │       └── shop_url_test.py
    └── .github/
        ├── CODE_OF_CONDUCT.md
        ├── ISSUE_TEMPLATE.md
        ├── PULL_REQUEST_TEMPLATE.md
        ├── api_update_reminder.md
        ├── api_update_reminder_on_release.md
        ├── dependabot.yml
        ├── ISSUE_TEMPLATE/
        │   ├── BUG_REPORT.md
        │   ├── ENHANCEMENT.md
        │   └── FEATURE_REQUEST.md
        └── workflows/
            ├── api_update_reminder.yml
            ├── api_update_reminder_on_release.yml
            ├── build.yml
            ├── cla.yml
            ├── close-waiting-for-response-issues.yml
            ├── pre-commit.yml
            ├── remove-labels-on-activity.yml
            └── stale.yml


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
File: README.md
================================================
# Shopify API

[![Build Status](https://github.com/Shopify/shopify_python_api/workflows/CI/badge.svg)](https://github.com/Shopify/shopify_python_api/actions)
[![PyPI version](https://badge.fury.io/py/ShopifyAPI.svg)](https://badge.fury.io/py/ShopifyAPI)
![Supported Python Versions](https://img.shields.io/badge/python-3.7%20|%203.8%20|%203.9%20|%203.10%20|%203.11%20|%203.12-brightgreen)
[![codecov](https://codecov.io/gh/Shopify/shopify_python_api/branch/main/graph/badge.svg?token=pNTx0TARUx)](https://codecov.io/gh/Shopify/shopify_python_api)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/Shopify/shopify_python_api/blob/main/LICENSE)
[![pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white)](https://github.com/pre-commit/pre-commit)

The [Shopify Admin API](https://shopify.dev/docs/admin-api) Python Library

## Usage

### Requirements
You should be signed up as a partner on the [Shopify Partners Dashboard](https://www.shopify.com/partners) so that you can create and manage shopify applications.

### Installation

To easily install or upgrade to the latest release, use [pip](http://www.pip-installer.org/).

```shell
pip install --upgrade ShopifyAPI
```

### Table of Contents

- [Usage](#usage)
  - [Requirements](#requirements)
  - [Installation](#installation)
  - [Table of Contents](#table-of-contents)
  - [Getting Started](#getting-started)
    - [Public and Custom Apps](#public-and-custom-apps)
    - [Private Apps](#private-apps)
      - [With full session](#with-full-session)
      - [With temporary session](#with-temporary-session)
  - [Billing](#billing)
  - [Advanced Usage](#advanced-usage)
  - [Prefix options](#prefix-options)
  - [Console](#console)
  - [GraphQL](#graphql)
- [Using Development Version](#using-development-version)
    - [Building and installing dev version](#building-and-installing-dev-version)
    - [Running Tests](#running-tests)
- [Relative Cursor Pagination](#relative-cursor-pagination)
- [Set up pre-commit locally \[OPTIONAL\]](#set-up-pre-commit-locally-optional)
- [Limitations](#limitations)
- [Additional Resources](#additional-resources)
  - [Sample apps built using this library](#sample-apps-built-using-this-library)


### Getting Started
#### Public and Custom Apps

1. First create a new application in the [Partners Dashboard](https://www.shopify.com/partners), and retrieve your API Key and API Secret Key.
1. We then need to supply these keys to the Shopify Session Class so that it knows how to authenticate.

   ```python
   import shopify

   shopify.Session.setup(api_key=API_KEY, secret=API_SECRET)
   ```
1.  In order to access a shop's data, apps need an access token from that specific shop. We need to authenticate with that shop using OAuth, which we can start in the following way:

    ```python
    shop_url = "SHOP_NAME.myshopify.com"
    api_version = '2024-07'
    state = binascii.b2a_hex(os.urandom(15)).decode("utf-8")
    redirect_uri = "http://myapp.com/auth/shopify/callback"
    # `scope` should be omitted if provided by app's TOML
    scopes = ['read_products', 'read_orders']

    newSession = shopify.Session(shop_url, api_version)
    # `scope` should be omitted if provided by app's TOML
    auth_url = newSession.create_permission_url(redirect_uri, scopes, state)
    # redirect to auth_url
    ```

1. Once the merchant accepts, the shop redirects the owner to the `redirect_uri` of your application with a parameter named 'code'. This is a temporary token that the app can exchange for a permanent access token. You should compare the state you provided above with the one you received back to ensure the request is correct. Now we can exchange the code for an access_token when you get the request from shopify in your callback handler:

    ```python
    session = shopify.Session(shop_url, api_version)
    access_token = session.request_token(request_params) # request_token will validate hmac and timing attacks
    # you should save the access token now for future use.
    ```

1.  Now you're ready to make authorized API requests to your shop!:

    ```python
    session = shopify.Session(shop_url, api_version, access_token)
    shopify.ShopifyResource.activate_session(session)

    # Note: REST API examples will be deprecated in 2025
    shop = shopify.Shop.current()  # Get the current shop
    product = shopify.Product.find(179761209)  # Get a specific product

    # GraphQL API example
    shopify.GraphQL().execute("{ shop { name id } }")
    ```

    Alternatively, you can use temp to initialize a Session and execute a command:

     ```python
     with shopify.Session.temp(shop_url, api_version, token):
        product = shopify.Product.find()
     ```

1.  It is best practice to clear your session when you're done. A temporary session does this automatically:

     ```python
     shopify.ShopifyResource.clear_session()
     ```

#### Private Apps
Private apps are a bit quicker to use because OAuth is not needed. You can create the private app in the Shopify Merchant Admin. You can use the Private App password as your `access_token`:

##### With full session
```python
session = shopify.Session(shop_url, api_version, private_app_password)
shopify.ShopifyResource.activate_session(session)
# ...
shopify.ShopifyResource.clear_session()
```

##### With temporary session

```python
with shopify.Session.temp(shop_url, api_version, private_app_password):
    shopify.GraphQL().execute("{ shop { name id } }")
```

### Billing
_Note: Your application must be public to test the billing process. To test on a development store use the `'test': True` flag_

1.  Create charge after session has been activated
    ```python
    application_charge = shopify.ApplicationCharge.create({
        'name': 'My public app',
        'price': 123,
        'test': True,
        'return_url': 'https://domain.com/approve'
    })
    # Redirect user to application_charge.confirmation_url so they can approve the charge
    ```
1.  After approving the charge, the user is redirected to `return_url` with `charge_id` parameter (_Note: This action is no longer necessary if the charge is created with [API version 2021-01 or later](https://shopify.dev/changelog/auto-activation-of-charges-and-subscriptions)_)
    ```python
    charge = shopify.ApplicationCharge.find(charge_id)
    shopify.ApplicationCharge.activate(charge)
    ```
1.  Check that `activated_charge` status is `active`
    ```python
    activated_charge = shopify.ApplicationCharge.find(charge_id)
    has_been_billed = activated_charge.status == 'active'
    ```

### Advanced Usage

> **⚠️ Note**: As of October 1, 2024, the REST Admin API is legacy:
> - Public apps must migrate to GraphQL by February 2025
> - Custom apps must migrate to GraphQL by April 2025
>
> For migration guidance, see [Shopify's migration guide](https://shopify.dev/docs/apps/build/graphql/migrate/new-product-model)

It is recommended to have at least a basic grasp on the principles of the [pyactiveresource](https://github.com/Shopify/pyactiveresource) library, which is a port of rails/ActiveResource to Python and upon which this package relies heavily.

Instances of `pyactiveresource` resources map to RESTful resources in the Shopify API.

`pyactiveresource` exposes life cycle methods for creating, finding, updating, and deleting resources which are equivalent to the `POST`, `GET`, `PUT`, and `DELETE` HTTP verbs.

```python
# Note: REST API examples will be deprecated in 2025
product = shopify.Product()
product.title = "Shopify Logo T-Shirt"
product.id                          # => 292082188312
product.save()                      # => True
shopify.Product.exists(product.id)  # => True
product = shopify.Product.find(292082188312)
# Resource holding our newly created Product object
# Inspect attributes with product.attributes
product.price = 19.99
product.save()                      # => True
product.destroy()
# Delete the resource from the remote server (i.e. Shopify)
```

Here is another example to retrieve a list of open orders using certain parameters:

```python
new_orders = shopify.Order.find(status="open", limit="50")
```

### Prefix options

Some resources such as `Fulfillment` are prefixed by a parent resource in the Shopify API (e.g. `orders/450789469/fulfillments/255858046`). In order to interact with these resources, you must specify the identifier of the parent resource in your request.

```python
# Note: This REST API example will be deprecated in the future
shopify.Fulfillment.find(255858046, order_id=450789469)
```

### Console
This package also includes the `shopify_api.py` script to make it easy to open an interactive console to use the API with a shop.
1.  Obtain a private API key and password to use with your shop (step 2 in "Getting Started")
1.  Save your default credentials: `shopify_api.py add yourshopname`
1.  Start the console for the connection: `shopify_api.py console`
1.  To see the full list of commands, type: `shopify_api.py help`

### GraphQL

This library also supports Shopify's new [GraphQL API](https://help.shopify.com/en/api/graphql-admin-api). The authentication process is identical. Once your session is activated, simply construct a new graphql client and use `execute` to execute the query.

> **Note**: Shopify recommends using GraphQL API for new development as REST API will be deprecated.
> See [Migration Guide](https://shopify.dev/docs/apps/build/graphql/migrate/new-product-model) for more details.

```python
result = shopify.GraphQL().execute('{ shop { name id } }')
```

You can perform more complex operations using the `variables` and `operation_name` parameters of `execute`.

For example, this GraphQL document uses a fragment to construct two named queries - one for a single order, and one for multiple orders:

```graphql
    # ./order_queries.graphql

    fragment OrderInfo on Order {
        id
        name
        createdAt
    }

    query GetOneOrder($order_id: ID!){
        node(id: $order_id){
            ...OrderInfo
        }
    }

    query GetManyOrders($order_ids: [ID]!){
        nodes(ids: $order_ids){
           ...OrderInfo
        }
    }
```

Now you can choose which operation to execute:

```python
# Load the document with both queries
document = Path("./order_queries.graphql").read_text()

# Specify the named operation to execute, and the parameters for the query
result = shopify.GraphQL().execute(
    query=document,
    variables={"order_id": "gid://shopify/Order/12345"},
    operation_name="GetOneOrder",
)
```

## Using Development Version

#### Building and installing dev version
```shell
python setup.py sdist
pip install --upgrade dist/ShopifyAPI-*.tar.gz
```

**Note** Use the `bin/shopify_api.py` script when running from the source tree. It will add the lib directory to start of sys.path, so the installed version won't be used.

#### Running Tests
```shell
pip install setuptools --upgrade
python setup.py test
```

## Relative Cursor Pagination
Cursor based pagination support has been added in 6.0.0.

```python
import shopify

page1 = shopify.Product.find()
if page1.has_next_page():
  page2 = page1.next_page()

# to persist across requests you can use next_page_url and previous_page_url
next_url = page1.next_page_url
page2 = shopify.Product.find(from_=next_url)
```

## Set up pre-commit locally [OPTIONAL]
[Pre-commit](https://pre-commit.com/) is set up as a GitHub action that runs on pull requests and pushes to the `main` branch. If you want to run pre-commit locally, install it and set up the git hook scripts
```shell
pip install -r requirements.txt
pre-commit install
```

## Limitations

Currently there is no support for:

* asynchronous requests
* persistent connections

## Additional Resources
* [Partners Dashboard](https://partners.shopify.com)
* [developers.shopify.com](https://developers.shopify.com)
* [Shopify.dev](https://shopify.dev)
* [Ask questions on the Shopify forums](http://ecommerce.shopify.com/c/shopify-apis-and-technology)

### Sample apps built using this library
* [Sample Django app](https://github.com/shopify/sample-django-app)


================================================
File: CHANGELOG
================================================
== Unreleased

- Remove requirement to provide scopes to Permission URL, as it should be omitted if defined with the TOML file.

== Version 12.7.0

- Remove requirement to use a predefined API version. Now you can use any valid API version string. ([#737](https://github.com/Shopify/shopify_python_api/pull/737))

== Version 12.6.0

- Update API version with 2024-07 release ([#723](https://github.com/Shopify/shopify_python_api/pull/723))

== Version 12.5.0

- Remove `cgi` import to avoid triggering a `DeprecationWarning` on Python 3.11.
- Update API version with 2024-04 release.([710](https://github.com/Shopify/shopify_python_api/pull/710))

== Version 12.4.0

- Update API version with 2023-07, 2023-10, 2024-01 releases ([#694](https://github.com/Shopify/shopify_python_api/pull/694))

== Version 12.3.0

- Update API version with 2023-04 release ([#649](https://github.com/Shopify/shopify_python_api/pull/649))

== Version 12.2.0

- Update API version with 2023-01 release ([#631](https://github.com/Shopify/shopify_python_api/pull/631))

== Version 12.1.0

- Add API version with 2022-10 release

== Version 12.0.1

- Allow up to 10 seconds clock skew to avoid `ImmatureSignatureError`
  ([#609](https://github.com/Shopify/shopify_python_api/pull/609))

== Version 12.0.0

- Update API version with 2022-04 release, remove API version 2021-07 ([#591](https://github.com/Shopify/shopify_python_api/pull/591))

== Version 11.0.0

- Update API version with 2022-04 release
- remove API version 2020-10, 2021-01, 2021-04 as they are all unsupported as of 2022-04

== Version 10.0.0

- Update API version with 2022-01 release, remove API version 2020-07

== Version 9.0.0

- Drop Python 2 support ([#549](https://github.com/Shopify/shopify_python_api/pull/549))
- Update API version with 2021-10 release, remove API version 2020-04 ([#548](https://github.com/Shopify/shopify_python_api/pull/548))

== Version 8.4.2

- Update API version with 2021-07 release, remove API version 2020-01 ([#521](https://github.com/Shopify/shopify_python_api/pull/521))

== Version 8.4.1

- Bug fix: `sanitize_shop_domain` now returns `None` rather than `'none.myshopify.com'` if no `shop_domain` arg is passed in ([#499](https://github.com/Shopify/shopify_python_api/pull/499))

== Version 8.4.0

- Revert Feature #441 Dynamic API Versioning ([#495](https://github.com/Shopify/shopify_python_api/pull/495))

== Version 8.3.1

- Fix bug: Add the `shopify/utils` sub-package when building the source distribution ([#493](https://github.com/Shopify/shopify_python_api/pull/493))

== Version 8.3.0

- Add support for [session tokens](https://shopify.dev/concepts/apps/building-embedded-apps-using-session-tokens) ([#479](https://github.com/Shopify/shopify_python_api/pull/479))
  - Use `session_token.decode_from_header` to obtain a decoded session token from an HTTP Authorization header
- Create a `utils` sub-package with a `shop_url` utility file ([#483](https://github.com/Shopify/shopify_python_api/pull/483))
  - Use `shop_url.sanitize_shop_domain()` to sanitize shop names given as input
- Introduce the `ApiAccess` class to handle access scopes operations for apps
  - `Session` class now store access_scopes attributes as `ApiAccess` objects
- Added support for Fulfillment.update_tracking ([#432](https://github.com/Shopify/shopify_python_api/pull/432))
- Add FulfillmentEvent resource ([#454](https://github.com/Shopify/shopify_python_api/pull/454))
- Fix for being unable to get the len() of a filter ([#456](https://github.com/Shopify/shopify_python_api/pull/456))
- Add ApplicationCredit resource ([#457](https://github.com/Shopify/shopify_python_api/pull/457))
- Add support for retrieving all orders using customer_id ([#466](https://github.com/Shopify/shopify_python_api/pull/466))

== Version 8.2.0

- [Feature] Add support for Dynamic API Versioning. When the library is initialized, it will now make a request to
  Shopify to fetch a list of the available API versions. ([#441](https://github.com/Shopify/shopify_python_api/pull/441))

== Version 8.1.0

- [Feature] Add support for Shopify Payments resources (#428)

== Version 8.0.4

- Release API version 2020-10
- Deprecate API version 2019-10

== Version 8.0.3

- Patch for replacing call to \_build_list() with \_build_collection() in gift_card.py

== Version 8.0.2

- Patch for product updating with variants

== Version 8.0.1

- release api version 2020-07
- deprecate api version 2019-07
- Add support for FulfillmentOrder resource (#390)

== Version 8.0.0

- release api version 2020-04
- deprecate api version 2019-04

== Version 7.0.3

- bug fix for temporary sessions
- deprecation fix for regexs

== Version 7.0.2

- bug fix for variant updates after the 2019-10 api version

== Version 7.0.1

- bug fix for string interpolation

== Version 7.0.0

- Made no_iter_next default to True on collection so that by default it only
  fetches a single page
- Passes kwargs to paginated collections so that attributes can be set with
  find()
- Allow case insensitive check for the link header for cursor pagination.

== Version 6.0.1

- Made the collection access more consistent so that there is no confusion
  between a collection and a paginated collection

== Version 6.0.0

- Add Cursor pagination support

== Version 5.1.2

- Add version 2020-01 to known ApiVersions. This version will not be usable until October 2019.

== Version 5.1.1

- Fix initializing API with basic auth URL.

== Version 5.1.0

- Added support for GraphQL queries with a GraphQL resource

== Version 5.0.1

- Fixing missing class variable causing exception when creating a session without a token

== Version 5.0.0

- Added support for Shopify API Versioning

== Version 4.0.0

- Added AccessScope resource
- Added ApiPermission resource
- Added User resource
- Added Publication, CollectionPublication and ProductPublication resources
- Added Currency resource
- Added TenderTransaction resource
- Added shopify.Limits class, for retrieving the current status of Shopify rate limiting.
- Added support for Refund.calculate
- Added support for Location.inventory_levels
- Added support for PriceRule batch operations
- Removed `cancel()` method for RecurringApplicationCharge resource (use `destroy()` going forward)
- Fix for handling array query parameters (e.g. `foo[]=1&foo[]=2`) during HMAC calculation
- Fixed Python 3 compatibility with the API console

== Version 3.1.0

- Adds InventoryItem resource
- Adds InventoryLevel resource
- Adds GiftCardAdjustment resource
- Fix to properly handle byte data for Asset.attach()

== Version 3.0.0

- Added CollectListing resource
- Added ResourceFeedback resource
- Added StorefrontAccessToken resource
- Added ProductListing resource
- Removed deprecated ProductSearchEngine resource
- Removed deprecated Discount resource
- Fixed Python3 compatibility issue with `Image.attach_image()`

== Version 2.6.0

- Added support for Marketing Event API through Marketing Event resource

== Version 2.5.1

- Fixed an issue preventing creation of Order Risk resources

== Version 2.5.0

- Added Price Rule and Discount Code resources

== Version 2.4.0

- Add support for report publishing

== Version 2.3.0

- Add support for customer#send_invite

== Version 2.2.0

- Add support for draft orders

== Version 2.1.8

- Added support for `open` method on fulfillments

== Version 2.1.7

- Removed all references to the deprecated MD5 `signature` parameter which is no longer provided by Shopify.

== Version 2.1.6

- Added Refund resource

== Version 2.1.5

- bump pyactiveresource for camelcase bugfix

== Version 2.1.4

== Version 2.1.3

- Fixed hmac signature validation for params with delimiters (`&`, `=` or `%`)

== Version 2.1.2

- Fixed an issue with unicode strings in params passed to validate_hmac
- Added shop domain verification when creating a session

== Version 2.1.1

- Added Checkout resource
- Updated to pyactiveresource v2.1.1 which includes a test-related bugfix
- Changed OAuth validation from MD5 to HMAC-SHA256

== Version 2.1.0

- Added python 3 compatibility
- Fixed setting the format attribute on carrier and fulfillment services
- Add a specific exception for signature validation failures

== Version 2.0.4

- Bug fixes
- Added CarrierService resource
- Added Property resource to LineItem

== Version 2.0.3

- Add Order Risk resource

== Version 2.0.2

- Add access to FulfillmentService endpoint
- Fix some import bugs

== Version 2.0.1

- Package bug fix

== Version 2.0.0

- Removed support for legacy auth
- Updated to pyactiveresource v2.0.0 which changes the default form to JSON
- in Session::request_token params is no longer optional, you must pass all the params
  and the method will now extract the code
- made create_permission_url an instance method, you'll need an instance
  of session to call this method from now on
- Updated session.request_token
- Updated Session to better match the ShopifyAPI Ruby gem
- Updated the readme to better describe how to use the library
- Added support for CustomerSavedSearch (CustomerGroup is deprecated)

== Version 1.0.7

- Fix thread local headers to store a copy of the default hash which
  prevents activate_session in one thread from affecting other threads.

== Version 1.0.6

- Fix deserializing and serializing fulfillments which can now contain
  arrays of strings in the tracking_urls attribute.

== Version 1.0.5

- Fix parameter passing for order cancellation.
- Fix Product.price_range method for variants with different prices.

== Version 1.0.4

- Fixed another bug in Image size methods regex.

== Version 1.0.3

- Fix bug in setting format attribute on Webhook instances.
- Fixed missing slash in return value of Image size methods
- Upgrade pyactiveresource to fix unicode encoding issues

== Version 1.0.2

- Made ShopifyResource.clear_session idempotent.

== Version 1.0.1

- Use the correct redirect parameter in Session.create_permission_url.
  Was redirect_url but corrected to redirect_uri.

== Version 1.0.0

- Added support for OAuth2.
- ShopifyResource.activate_session must now be used with OAuth2 instead
  of setting ShopifyResource.site directly.
- Session.**init** no longer allows params to be passed in as \*\*params
- Session.**init** now makes an HTTP request when using OAuth2 if
  params are specified
- Session now exposes the access token through the token instance
  variable to simplify session saving and resuming

== Version 0.4.0

- Using setup.py no longer requires all dependencies
- More compatibility fixes for using the latest pyactiveresource
- ShopifyResource.activate_session is not recommended over setting site
  directly for forward compatibility with coming OAuth2 changes.

== Version 0.3.1

- Compatibility fixes for using latest (unreleased) pyactiveresource

== Version 0.3.0

- Added support for customer search and customer group search.
- Resource errors are cleared on save from previous save attempt.
- Made the library thread-safe using thread-local connections.

== Version 0.2.1

- Fixed a regression that caused a different connection
  object to be created on each resource.

== Version 0.2.0

- Made responses available through the connection object.

== Version 0.1.8

- Added ability to add metafields on customers.

== Version 0.1.7

- Fixed missing theme_id in return value of Asset.find.

== Version 0.1.6

- Fixed attribute setting on Asset objects
- Strip path from shop_url to get just the shop's domain.

== Version 0.1.5

- Fixed Asset.find()
- Fixed Variant.find(id)
- Allow running from source directory with PYTHONPATH=./lib

== Version 0.1.4

- Fixed a bug in metafields method caused by missing import.
- Prefix options can be specified in the attributes dict on creation
- Allow count method to be used the same way as find

== Version 0.1.3

- Fixed the automatic download of dependencies.
- Updated the README instructions.

== Version 0.1.2

- Add python 2.5 compatibility

== Version 0.1.1

- Make creating a session simpler with django

== Version 0.1.0

- ported ShopifyAPI from ruby to python


================================================
File: CONTRIBUTING.md
================================================
Submitting Issues
-----------------

Please open an issue here if you encounter a specific bug with this API client library or if something is documented here https://docs.shopify.com/api but is missing from this package.

General questions about the Shopify API and usage of this package (not necessarily a bug) should be posted on the [Shopify forums](https://ecommerce.shopify.com/c/shopify-apis-and-technology).

For compatibility across Python 2 and Python 3, look into [Six](https://six.readthedocs.io/).

When in doubt, post on the forum first. You'll likely have your questions answered more quickly if you post there; more people monitor the forum than Github.


================================================
File: LICENSE
================================================
Copyright (c) 2011 "JadedPixel inc."

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


================================================
File: MANIFEST.in
================================================
include LICENSE
include CHANGELOG
include README.md
include bin/shopify_api.py


================================================
File: RELEASING
================================================
Releasing shopify_python_api

1. Verify that the examples in the README are still valid against the latest stable API release.

2. Check the Semantic Versioning page for info on how to version the new release: http://semver.org

3. Update version in shopify/version.py

4. Update CHANGELOG entry for the release.

5. Commit the changes
    git commit -m "Release vX.Y.Z"

6. Tag the release with the version
    git tag -m "Release X.Y.Z" vX.Y.Z

7. Push the changes to github
    git push --tags origin main

8. Shipit!


================================================
File: SECURITY.md
================================================
# Security Policy

## Supported versions

### New features

New features will only be added to the main branch and will not be made available in point releases.

### Bug fixes

Only the latest release series will receive bug fixes. When enough bugs are fixed and its deemed worthy to release a new gem, this is the branch it happens from.

### Security issues

Only the latest release series will receive patches and new versions in case of a security issue.

### Severe security issues

For severe security issues we will provide new versions as above, and also the last major release series will receive patches and new versions. The classification of the security issue is judged by the core team.

### Unsupported Release Series

When a release series is no longer supported, it's your own responsibility to deal with bugs and security issues. If you are not comfortable maintaining your own versions, you should upgrade to a supported version.

## Reporting a bug

All security bugs in shopify repositories should be reported to [our hackerone program](https://hackerone.com/shopify)
Shopify's whitehat program is our way to reward security researchers for finding serious security vulnerabilities in the In Scope properties listed at the bottom of this page, including our core application (all functionality associated with a Shopify store, particularly your-store.myshopify.com/admin) and certain ancillary applications.

## Disclosure Policy

We look forward to working with all security researchers and strive to be respectful, always assume the best and treat others as peers. We expect the same in return from all participants. To achieve this, our team strives to:

- Reply to all reports within one business day and triage within two business days (if applicable)
- Be as transparent as possible, answering all inquires about our report decisions and adding hackers to duplicate HackerOne reports
- Award bounties within a week of resolution (excluding extenuating circumstances)
- Only close reports as N/A when the issue reported is included in Known Issues, Ineligible Vulnerabilities Types or lacks evidence of a vulnerability

**The following rules must be followed in order for any rewards to be paid:**

- You may only test against shops you have created which include your HackerOne YOURHANDLE @ wearehackerone.com registered email address.
- You must not attempt to gain access to, or interact with, any shops other than those created by you.
- The use of commercial scanners is prohibited (e.g., Nessus).
- Rules for reporting must be followed.
- Do not disclose any issues publicly before they have been resolved.
- Shopify reserves the right to modify the rules for this program or deem any submissions invalid at any time. Shopify may cancel the whitehat program without notice at any time.
- Contacting Shopify Support over chat, email or phone about your HackerOne report is not allowed. We may disqualify you from receiving a reward, or from participating in the program altogether.
- You are not an employee of Shopify; employees should report bugs to the internal bug bounty program.
- You hereby represent, warrant and covenant that any content you submit to Shopify is an original work of authorship and that you are legally entitled to grant the rights and privileges conveyed by these terms. You further represent, warrant and covenant that the consent of no other person or entity is or will be necessary for Shopify to use the submitted content.
- By submitting content to Shopify, you irrevocably waive all moral rights which you may have in the content.
- All content submitted by you to Shopify under this program is licensed under the MIT License.
- You must report any discovered vulnerability to Shopify as soon as you have validated the vulnerability.
- Failure to follow any of the foregoing rules will disqualify you from participating in this program.

** Please see our [Hackerone Profile](https://hackerone.com/shopify) for full details

## Receiving Security Updates

To recieve all general updates to vulnerabilities, please subscribe to our hackerone [Hacktivity](https://hackerone.com/shopify/hacktivity)


================================================
File: dev.yml
================================================
---
name: shopify-python-api

type: python

up:
  - python: 3.8.13
  - pip:
      - requirements.txt

commands:
  test: python setup.py test


================================================
File: pylintrc
================================================
# This Pylint rcfile contains a best-effort configuration to uphold the
# best-practices and style described in the Google Python style guide:
#   https://google.github.io/styleguide/pyguide.html
#
# Its canonical open-source location is:
#   https://google.github.io/styleguide/pylintrc

[MASTER]

# Files or directories to be skipped. They should be base names, not paths.
ignore=third_party

# Files or directories matching the regex patterns are skipped. The regex
# matches against base names, not paths.
ignore-patterns=

# Pickle collected data for later comparisons.
persistent=no

# List of plugins (as comma separated values of python modules names) to load,
# usually to register additional checkers.
load-plugins=

# Use multiple processes to speed up Pylint.
jobs=4

# Allow loading of arbitrary C extensions. Extensions are imported into the
# active Python interpreter and may run arbitrary code.
unsafe-load-any-extension=no


[MESSAGES CONTROL]

# Only show warnings with the listed confidence levels. Leave empty to show
# all. Valid levels: HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED
confidence=INFERENCE

# Enable the message, report, category or checker with the given id(s). You can
# either give multiple identifier separated by comma (,) or put this option
# multiple time (only on the command line, not in the configuration file where
# it should appear only once). See also the "--disable" option for examples.
#enable=

# Disable the message, report, category or checker with the given id(s). You
# can either give multiple identifiers separated by comma (,) or put this
# option multiple times (only on the command line, not in the configuration
# file where it should appear only once).You can also use "--disable=all" to
# disable everything first and then reenable specific checks. For example, if
# you want to run only the similarities checker, you can use "--disable=all
# --enable=similarities". If you want to run only the classes checker, but have
# no Warning level messages displayed, use"--disable=all --enable=classes
# --disable=W"
disable=abstract-method,
        apply-builtin,
        arguments-differ,
        attribute-defined-outside-init,
        backtick,
        bad-option-value,
        basestring-builtin,
        buffer-builtin,
        c-extension-no-member,
        consider-using-enumerate,
        cmp-builtin,
        cmp-method,
        coerce-builtin,
        coerce-method,
        delslice-method,
        div-method,
        duplicate-code,
        eq-without-hash,
        execfile-builtin,
        file-builtin,
        filter-builtin-not-iterating,
        fixme,
        getslice-method,
        global-statement,
        hex-method,
        idiv-method,
        implicit-str-concat-in-sequence,
        import-error,
        import-self,
        import-star-module-level,
        inconsistent-return-statements,
        input-builtin,
        intern-builtin,
        invalid-str-codec,
        locally-disabled,
        long-builtin,
        long-suffix,
        map-builtin-not-iterating,
        misplaced-comparison-constant,
        missing-class-docstring,
        missing-function-docstring,
        missing-module-docstring,
        metaclass-assignment,
        next-method-called,
        next-method-defined,
        no-absolute-import,
        no-else-break,
        no-else-continue,
        no-else-raise,
        no-else-return,
        no-init,  # added
        no-member,
        no-name-in-module,
        no-self-use,
        nonzero-method,
        oct-method,
        old-division,
        old-ne-operator,
        old-octal-literal,
        old-raise-syntax,
        parameter-unpacking,
        print-statement,
        raising-string,
        range-builtin-not-iterating,
        raw_input-builtin,
        rdiv-method,
        reduce-builtin,
        relative-import,
        reload-builtin,
        round-builtin,
        setslice-method,
        signature-differs,
        standarderror-builtin,
        suppressed-message,
        sys-max-int,
        too-few-public-methods,
        too-many-ancestors,
        too-many-arguments,
        too-many-boolean-expressions,
        too-many-branches,
        too-many-instance-attributes,
        too-many-locals,
        too-many-nested-blocks,
        too-many-public-methods,
        too-many-return-statements,
        too-many-statements,
        trailing-newlines,
        unichr-builtin,
        unicode-builtin,
        unnecessary-pass,
        unpacking-in-except,
        useless-else-on-loop,
        useless-object-inheritance,
        useless-suppression,
        using-cmp-argument,
        wrong-import-order,
        xrange-builtin,
        zip-builtin-not-iterating,


[REPORTS]

# Set the output format. Available formats are text, parseable, colorized, msvs
# (visual studio) and html. You can also give a reporter class, eg
# mypackage.mymodule.MyReporterClass.
output-format=text

# Put messages in a separate file for each module / package specified on the
# command line instead of printing them on stdout. Reports (if any) will be
# written in a file name "pylint_global.[txt|html]". This option is deprecated
# and it will be removed in Pylint 2.0.
files-output=no

# Tells whether to display a full report or only the messages
reports=no

# Python expression which should return a note less than 10 (10 is the highest
# note). You have access to the variables errors warning, statement which
# respectively contain the number of errors / warnings messages and the total
# number of statements analyzed. This is used by the global evaluation report
# (RP0004).
evaluation=10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)

# Template used to display messages. This is a python new-style format string
# used to format the message information. See doc for all details
#msg-template=


[BASIC]

# Good variable names which should always be accepted, separated by a comma
good-names=main,_

# Bad variable names which should always be refused, separated by a comma
bad-names=

# Colon-delimited sets of names that determine each other's naming style when
# the name regexes allow several styles.
name-group=

# Include a hint for the correct naming format with invalid-name
include-naming-hint=no

# List of decorators that produce properties, such as abc.abstractproperty. Add
# to this list to register other decorators that produce valid properties.
property-classes=abc.abstractproperty,cached_property.cached_property,cached_property.threaded_cached_property,cached_property.cached_property_with_ttl,cached_property.threaded_cached_property_with_ttl

# Regular expression matching correct function names
function-rgx=^(?:(?P<exempt>setUp|tearDown|setUpModule|tearDownModule)|(?P<camel_case>_?[A-Z][a-zA-Z0-9]*)|(?P<snake_case>_?[a-z][a-z0-9_]*))$

# Regular expression matching correct variable names
variable-rgx=^[a-z][a-z0-9_]*$

# Regular expression matching correct constant names
const-rgx=^(_?[A-Z][A-Z0-9_]*|__[a-z0-9_]+__|_?[a-z][a-z0-9_]*)$

# Regular expression matching correct attribute names
attr-rgx=^_{0,2}[a-z][a-z0-9_]*$

# Regular expression matching correct argument names
argument-rgx=^[a-z][a-z0-9_]*$

# Regular expression matching correct class attribute names
class-attribute-rgx=^(_?[A-Z][A-Z0-9_]*|__[a-z0-9_]+__|_?[a-z][a-z0-9_]*)$

# Regular expression matching correct inline iteration names
inlinevar-rgx=^[a-z][a-z0-9_]*$

# Regular expression matching correct class names
class-rgx=^_?[A-Z][a-zA-Z0-9]*$

# Regular expression matching correct module names
module-rgx=^(_?[a-z][a-z0-9_]*|__init__)$

# Regular expression matching correct method names
method-rgx=(?x)^(?:(?P<exempt>_[a-z0-9_]+__|runTest|setUp|tearDown|setUpTestCase|tearDownTestCase|setupSelf|tearDownClass|setUpClass|(test|assert)_*[A-Z0-9][a-zA-Z0-9_]*|next)|(?P<camel_case>_{0,2}[A-Z][a-zA-Z0-9_]*)|(?P<snake_case>_{0,2}[a-z][a-z0-9_]*))$

# Regular expression which should only match function or class names that do
# not require a docstring.
no-docstring-rgx=(__.*__|main|test.*|.*test|.*Test)$

# Minimum line length for functions/classes that require docstrings, shorter
# ones are exempt.
docstring-min-length=10


[TYPECHECK]

# List of decorators that produce context managers, such as
# contextlib.contextmanager. Add to this list to register other decorators that
# produce valid context managers.
contextmanager-decorators=contextlib.contextmanager,contextlib2.contextmanager

# Tells whether missing members accessed in mixin class should be ignored. A
# mixin class is detected if its name ends with "mixin" (case insensitive).
ignore-mixin-members=yes

# List of module names for which member attributes should not be checked
# (useful for modules/projects where namespaces are manipulated during runtime
# and thus existing member attributes cannot be deduced by static analysis. It
# supports qualified module names, as well as Unix pattern matching.
ignored-modules=

# List of class names for which member attributes should not be checked (useful
# for classes with dynamically set attributes). This supports the use of
# qualified names.
ignored-classes=optparse.Values,thread._local,_thread._local

# List of members which are set dynamically and missed by pylint inference
# system, and so shouldn't trigger E1101 when accessed. Python regular
# expressions are accepted.
generated-members=


[FORMAT]

# Maximum number of characters on a single line.
max-line-length=120

# TODO(https://github.com/PyCQA/pylint/issues/3352): Direct pylint to exempt
# lines made too long by directives to pytype.

# Regexp for a line that is allowed to be longer than the limit.
ignore-long-lines=(?x)(
  ^\s*(\#\ )?<?https?://\S+>?$|
  ^\s*(from\s+\S+\s+)?import\s+.+$)

# Allow the body of an if to be on the same line as the test if there is no
# else.
single-line-if-stmt=yes

# List of optional constructs for which whitespace checking is disabled. `dict-
# separator` is used to allow tabulation in dicts, etc.: {1  : 1,\n222: 2}.
# `trailing-comma` allows a space between comma and closing bracket: (a, ).
# `empty-line` allows space-only lines.
no-space-check=

# Maximum number of lines in a module
max-module-lines=99999

# String used as indentation unit.  The internal Google style guide mandates 2
# spaces.  Google's externaly-published style guide says 4, consistent with
# PEP 8.  Here, we use 2 spaces, for conformity with many open-sourced Google
# projects (like TensorFlow).
indent-string='    '

# Number of spaces of indent required inside a hanging  or continued line.
indent-after-paren=4

# Expected format of line ending, e.g. empty (any line ending), LF or CRLF.
expected-line-ending-format=


[MISCELLANEOUS]

# List of note tags to take in consideration, separated by a comma.
notes=TODO


[STRING]

# This flag controls whether inconsistent-quotes generates a warning when the
# character used as a quote delimiter is used inconsistently within a module.
check-quote-consistency=yes


[VARIABLES]

# Tells whether we should check for unused import in __init__ files.
init-import=no

# A regular expression matching the name of dummy variables (i.e. expectedly
# not used).
dummy-variables-rgx=^\*{0,2}(_$|unused_|dummy_)

# List of additional names supposed to be defined in builtins. Remember that
# you should avoid to define new builtins when possible.
additional-builtins=

# List of strings which can identify a callback function by name. A callback
# name must start or end with one of those strings.
callbacks=cb_,_cb

# List of qualified module names which can have objects that can redefine
# builtins.
redefining-builtins-modules=six,six.moves,past.builtins,future.builtins,functools


[LOGGING]

# Logging modules to check that the string format arguments are in logging
# function parameter format
logging-modules=logging,absl.logging,tensorflow.io.logging


[SIMILARITIES]

# Minimum lines number of a similarity.
min-similarity-lines=4

# Ignore comments when computing similarities.
ignore-comments=yes

# Ignore docstrings when computing similarities.
ignore-docstrings=yes

# Ignore imports when computing similarities.
ignore-imports=no


[SPELLING]

# Spelling dictionary name. Available dictionaries: none. To make it working
# install python-enchant package.
spelling-dict=

# List of comma separated words that should not be checked.
spelling-ignore-words=

# A path to a file that contains private dictionary; one word per line.
spelling-private-dict-file=

# Tells whether to store unknown words to indicated private dictionary in
# --spelling-private-dict-file option instead of raising a message.
spelling-store-unknown-words=no


[IMPORTS]

# Deprecated modules which should not be used, separated by a comma
deprecated-modules=regsub,
                   TERMIOS,
                   Bastion,
                   rexec,
                   sets

# Create a graph of every (i.e. internal and external) dependencies in the
# given file (report RP0402 must not be disabled)
import-graph=

# Create a graph of external dependencies in the given file (report RP0402 must
# not be disabled)
ext-import-graph=

# Create a graph of internal dependencies in the given file (report RP0402 must
# not be disabled)
int-import-graph=

# Force import order to recognize a module as part of the standard
# compatibility libraries.
known-standard-library=

# Force import order to recognize a module as part of a third party library.
known-third-party=enchant, absl

# Analyse import fallback blocks. This can be used to support both Python 2 and
# 3 compatible code, which means that the block might have code that exists
# only in one or another interpreter, leading to false positives when analysed.
analyse-fallback-blocks=no


[CLASSES]

# List of method names used to declare (i.e. assign) instance attributes.
defining-attr-methods=__init__,
                      __new__,
                      setUp

# List of member names, which should be excluded from the protected access
# warning.
exclude-protected=_asdict,
                  _fields,
                  _replace,
                  _source,
                  _make

# List of valid names for the first argument in a class method.
valid-classmethod-first-arg=cls,
                            class_

# List of valid names for the first argument in a metaclass class method.
valid-metaclass-classmethod-first-arg=mcs


[EXCEPTIONS]

# Exceptions that will emit a warning when being caught. Defaults to
# "Exception"
overgeneral-exceptions=StandardError,
                       Exception,
                       BaseException


================================================
File: pyproject.toml
================================================
[tool.autopep8]
max_line_length = 120

[tool.black]
line-length = 120


================================================
File: requirements.txt
================================================
setuptools


================================================
File: setup.py
================================================
from setuptools import setup

NAME = "ShopifyAPI"
exec(open("shopify/version.py").read())
DESCRIPTION = "Shopify API for Python"
LONG_DESCRIPTION = """\
The ShopifyAPI library allows python developers to programmatically
access the admin section of stores using an ActiveResource like
interface similar the ruby Shopify API gem. The library makes HTTP
requests to Shopify in order to list, create, update, or delete
resources (e.g. Order, Product, Collection)."""

setup(
    name=NAME,
    version=VERSION,
    description=DESCRIPTION,
    long_description=LONG_DESCRIPTION,
    author="Shopify",
    author_email="developers@shopify.com",
    url="https://github.com/Shopify/shopify_python_api",
    packages=["shopify", "shopify/resources", "shopify/utils"],
    scripts=["scripts/shopify_api.py"],
    license="MIT License",
    install_requires=[
        "pyactiveresource>=2.2.2",
        "PyJWT >= 2.0.0",
        "PyYAML>=6.0.1; python_version>='3.12'",
        "PyYAML; python_version<'3.12'",
        "six",
    ],
    test_suite="test",
    tests_require=[
        "mock>=1.0.1",
    ],
    platforms="Any",
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Topic :: Software Development",
        "Topic :: Software Development :: Libraries",
        "Topic :: Software Development :: Libraries :: Python Modules",
    ],
)


================================================
File: shipit.pypi.yml
================================================
deploy:
  override:
    - assert-egg-version-tag setup.py
    - python setup.py sdist
    - twine upload --repository-url https://upload.pypi.org/legacy/ -u shopify -p $PYPI_PASSWORD_SHOPIFY dist/*


================================================
File: tox.ini
================================================
[tox]
envlist = py27, py34, py35, py36, py38, py39
skip_missing_interpreters = true

[testenv]
setenv =
    PYTHONPATH = {toxinidir}:{toxinidir}/shopify
commands=
    python setup.py test

[testenv:flake8]
basepython=python
deps=
    flake8
    flake8_docstrings
commands=
    flake8 shopify

[flake8]
ignore = E126,E128
max-line-length = 99
exclude = .ropeproject
max-complexity = 10


================================================
File: .pre-commit-config.yaml
================================================
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
  - repo: https://github.com/psf/black
    rev: 24.10.0
    hooks:
      - id: black
  - repo: https://github.com/PyCQA/pylint
    rev: v3.3.3
    hooks:
      - id: pylint


================================================
File: bin/shopify_api.py
================================================
#!/usr/bin/env python
"""shopify_api.py wrapper script for running it the source directory"""

import sys
import os.path

# Use the development rather than installed version
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

with open(os.path.join(project_root, "scripts", "shopify_api.py")) as f:
    code = compile(f.read(), f.name, "exec")
    exec(code)


================================================
File: docs/api-access.md
================================================
# Handling access scope operations

#### Table of contents

- [Common ApiAccess operations](#common-apiaccess-operations)
- [Using ApiAccess to handle changes in app access scopes](#using-apiaccess-to-handle-changes-in-app-access-scopes)

There are common operations that are used for managing [access scopes](https://shopify.dev/docs/admin-api/access-scopes) in apps. Such operations include serializing, deserializing and normalizing scopes. Other operations can include checking whether two sets of scopes grant the same API access or whether one set covers the access granted by another set.

To encapsulate the access granted by access scopes, you can use the `ApiAccess` value object.

## Common ApiAccess operations

### Constructing an ApiAccess

```python
api_access = ApiAccess(["read_products", "write_orders"]) # List of access scopes
another_api_access = ApiAccess("read_products, write_products, unauthenticated_read_themes") # String of comma-delimited access scopes
```

### Serializing ApiAccess

```python
api_access = ApiAccess(["read_products", "write_orders", "unauthenticated_read_themes"])

access_scopes_list = list(api_access) # ["read_products", "write_orders", "unauthenticated_read_themes"]
comma_delimited_access_scopes = str(api_access) # "read_products,write_orders,unauthenticated_read_themes"
```

### Comparing ApiAccess objects

#### Checking for API access equality

```python
expected_api_access = ApiAccess(["read_products", "write_orders"])

actual_api_access = ApiAccess(["read_products", "read_orders", "write_orders"])
non_equal_api_access = ApiAccess(["read_products", "write_orders", "read_themes"])

actual_api_access == expected_api_access # True
non_equal_api_access == expected_api_access # False
```

#### Checking if ApiAccess covers the access of another

```python
superset_access = ApiAccess(["write_products", "write_orders", "read_themes"])
subset_access = ApiAccess(["read_products", "write_orders"])

superset_access.covers(subset_access) # True
```

## Using ApiAccess to handle changes in app access scopes

If your app has changes in the access scopes it requests, you can use the `ApiAccess` object to determine whether the merchant needs to go through OAuth based on the scopes currently granted. A sample decorator shows how this can be achieved when loading an app.

```python
from shopify import ApiAccess


def oauth_on_access_scopes_mismatch(func):
  def wrapper(*args, **kwargs):
    shop_domain = get_shop_query_parameter(request) # shop query param when loading app
    current_shop_scopes = ApiAccess(ShopStore.get_record(shopify_domain = shop_domain).access_scopes)
    expected_access_scopes = ApiAccess(SHOPIFY_API_SCOPES)

    if current_shop_scopes != expected_access_scopes:
      return redirect_to_login() # redirect to OAuth to update access scopes granted

    return func(*args, **kwargs)

  return wrapper
```


================================================
File: docs/session-tokens.md
================================================
# Session tokens

The Shopify Python API library provides helper methods to decode [session tokens](https://shopify.dev/concepts/apps/building-embedded-apps-using-session-tokens). You can use the `decode_from_header` function to extract and decode a session token from an HTTP Authorization header.

## Basic usage

```python
from shopify import session_token

decoded_payload = session_token.decode_from_header(
    authorization_header=your_auth_request_header,
    api_key=your_api_key,
    secret=your_api_secret,
)
```

## Create a decorator using `session_token`

Here's a sample decorator that protects your app views/routes by requiring the presence of valid session tokens as part of a request's headers.

```python
from shopify import session_token


def session_token_required(func):
    def wrapper(*args, **kwargs):
        request = args[0]  # Or flask.request if you use Flask
        try:
            decoded_session_token = session_token.decode_from_header(
                authorization_header = request.headers.get('Authorization'),
                api_key = SHOPIFY_API_KEY,
                secret = SHOPIFY_API_SECRET
            )
            with shopify_session(decoded_session_token):
                return func(*args, **kwargs)
        except session_token.SessionTokenError as e:
            # Log the error here
            return unauthorized_401_response()

    return wrapper


def shopify_session(decoded_session_token):
    shopify_domain = decoded_session_token.get("dest")
    access_token = get_offline_access_token_by_shop_domain(shopify_domain)

    return shopify.Session.temp(shopify_domain, SHOPIFY_API_VERSION, access_token)


@session_token_required  # Requests to /products require session tokens
def products(request):
    products = shopify.Product.find()
    ...
```


================================================
File: scripts/shopify_api.py
================================================
#!/usr/bin/env python

import shopify
import code
import sys
import os
import os.path
import glob
import subprocess
import functools
import yaml
import six
from six.moves import input, map


def start_interpreter(**variables):
    # add the current working directory to the sys paths
    sys.path.append(os.getcwd())
    try:
        from IPython import start_ipython
        from traitlets.config.loader import Config

        config = Config(TerminalInteractiveShell={"banner2": "(shopify %s)" % shopify.version.VERSION})
        start_ipython(argv=[], user_ns=variables, config=config)

    except ImportError:
        console = type("shopify " + shopify.version.VERSION, (code.InteractiveConsole, object), {})
        import readline

        console(variables).interact()


class ConfigFileError(Exception):
    pass


def usage(usage_string):
    """Decorator to add a usage string to a function"""

    def decorate(func):
        func.usage = usage_string
        return func

    return decorate


class TasksMeta(type):
    _prog = os.path.basename(sys.argv[0])

    def __new__(mcs, name, bases, new_attrs):
        cls = type.__new__(mcs, name, bases, new_attrs)

        tasks = list(new_attrs.keys())
        tasks.append("help")

        def filter_func(item):
            return not item.startswith("_") and hasattr(getattr(cls, item), "__call__")

        tasks = filter(filter_func, tasks)
        cls._tasks = sorted(tasks)

        return cls

    def run_task(cls, task=None, *args):
        if task in [None, "-h", "--help"]:
            cls.help()
            return

        # Allow unambiguous abbreviations of tasks
        if task not in cls._tasks:
            matches = filter(lambda item: item.startswith(task), cls._tasks)
            list_of_matches = list(matches)
            if len(list_of_matches) == 1:
                task = list_of_matches[0]
            else:
                sys.stderr.write('Could not find task "%s".\n' % (task))

        task_func = getattr(cls, task)
        task_func(*args)

    @usage("help [TASK]")
    def help(cls, task=None):
        """Describe available tasks or one specific task"""
        if task is None:
            usage_list = []
            for task in iter(cls._tasks):
                task_func = getattr(cls, task)
                usage_string = "  %s %s" % (cls._prog, task_func.usage)
                desc = task_func.__doc__.splitlines()[0]
                usage_list.append((usage_string, desc))
            max_len = functools.reduce(lambda m, item: max(m, len(item[0])), usage_list, 0)
            print("Tasks:")
            cols = int(os.environ.get("COLUMNS", 80))
            for line, desc in usage_list:
                task_func = getattr(cls, task)
                if desc:
                    line = "%s%s  # %s" % (line, " " * (max_len - len(line)), desc)
                if len(line) > cols:
                    line = line[: cols - 3] + "..."
                print(line)
        else:
            task_func = getattr(cls, task)
            print("Usage:")
            print("  %s %s" % (cls._prog, task_func.usage))
            print("")
            print(task_func.__doc__)


@six.add_metaclass(TasksMeta)
class Tasks(object):
    _shop_config_dir = os.path.join(os.environ["HOME"], ".shopify", "shops")
    _default_symlink = os.path.join(_shop_config_dir, "default")
    _default_api_version = "unstable"

    @classmethod
    @usage("list")
    def list(cls):
        """list available connections"""
        for c in cls._available_connections():
            prefix = " * " if cls._is_default(c) else "   "
            print(prefix + c)

    @classmethod
    @usage("add CONNECTION")
    def add(cls, connection):
        """create a config file for a connection named CONNECTION"""
        filename = cls._get_config_filename(connection)
        if os.path.exists(filename):
            raise ConfigFileError("There is already a config file at " + filename)
        else:
            config = {"protocol": "https"}
            domain = input("Domain? (leave blank for %s.myshopify.com) " % (connection))
            if not domain.strip():
                domain = "%s.myshopify.com" % (connection)
            config["domain"] = domain
            print("")
            print("open https://%s/admin/apps/private in your browser to generate API credentials" % (domain))
            config["api_key"] = input("API key? ")
            config["password"] = input("Password? ")
            config["api_version"] = input("API version? (leave blank for %s) " % (cls._default_api_version))
            if not config["api_version"].strip():
                config["api_version"] = cls._default_api_version

            if not os.path.isdir(cls._shop_config_dir):
                os.makedirs(cls._shop_config_dir)
            with open(filename, "w") as f:
                f.write(yaml.dump(config, default_flow_style=False, explicit_start="---"))
        if len(list(cls._available_connections())) == 1:
            cls.default(connection)

    @classmethod
    @usage("remove CONNECTION")
    def remove(cls, connection):
        """remove the config file for CONNECTION"""
        filename = cls._get_config_filename(connection)
        if os.path.exists(filename):
            if cls._is_default(connection):
                os.remove(cls._default_symlink)
            os.remove(filename)
        else:
            cls._no_config_file_error(filename)

    @classmethod
    @usage("edit [CONNECTION]")
    def edit(cls, connection=None):
        """open the config file for CONNECTION with you default editor"""
        filename = cls._get_config_filename(connection)
        if os.path.exists(filename):
            editor = os.environ.get("EDITOR")
            if editor:
                subprocess.call([editor, filename])
            else:
                print("Please set an editor in the EDITOR environment variable")
        else:
            cls._no_config_file_error(filename)

    @classmethod
    @usage("show [CONNECTION]")
    def show(cls, connection=None):
        """output the location and contents of the CONNECTION's config file"""
        if connection is None:
            connection = cls._default_connection()
        filename = cls._get_config_filename(connection)
        if os.path.exists(filename):
            print(filename)
            with open(filename) as f:
                print(f.read())
        else:
            cls._no_config_file_error(filename)

    @classmethod
    @usage("default [CONNECTION]")
    def default(cls, connection=None):
        """show the default connection, or make CONNECTION the default"""
        if connection is not None:
            target = cls._get_config_filename(connection)
            if os.path.exists(target):
                if os.path.exists(cls._default_symlink):
                    os.remove(cls._default_symlink)
                os.symlink(target, cls._default_symlink)
            else:
                cls._no_config_file_error(target)
        if os.path.exists(cls._default_symlink):
            print("Default connection is " + cls._default_connection())
        else:
            print("There is no default connection set")

    @classmethod
    @usage("console [CONNECTION]")
    def console(cls, connection=None):
        """start an API console for CONNECTION"""
        filename = cls._get_config_filename(connection)
        if not os.path.exists(filename):
            cls._no_config_file_error(filename)

        with open(filename) as f:
            config = yaml.safe_load(f.read())
        print("using %s" % (config["domain"]))
        session = cls._session_from_config(config)
        shopify.ShopifyResource.activate_session(session)

        start_interpreter(shopify=shopify)

    @classmethod
    @usage("version")
    def version(cls):
        """output the shopify library version"""
        print(shopify.version.VERSION)

    @classmethod
    def _available_connections(cls):
        return map(
            lambda item: os.path.splitext(os.path.basename(item))[0],
            glob.glob(os.path.join(cls._shop_config_dir, "*.yml")),
        )

    @classmethod
    def _default_connection_target(cls):
        if not os.path.exists(cls._default_symlink):
            return None
        target = os.readlink(cls._default_symlink)
        return os.path.join(cls._shop_config_dir, target)

    @classmethod
    def _default_connection(cls):
        target = cls._default_connection_target()
        if not target:
            return None
        return os.path.splitext(os.path.basename(target))[0]

    @classmethod
    def _get_config_filename(cls, connection):
        if connection is None:
            return cls._default_symlink
        else:
            return os.path.join(cls._shop_config_dir, connection + ".yml")

    @classmethod
    def _session_from_config(cls, config):
        session = shopify.Session(config.get("domain"), config.get("api_version", cls._default_api_version))
        session.protocol = config.get("protocol", "https")
        session.api_key = config.get("api_key")
        session.token = config.get("password")
        return session

    @classmethod
    def _is_default(cls, connection):
        return connection == cls._default_connection()

    @classmethod
    def _no_config_file_error(cls, filename):
        raise ConfigFileError("There is no config file at " + filename)


try:
    Tasks.run_task(*sys.argv[1:])
except ConfigFileError as e:
    print(e)


================================================
File: shopify/__init__.py
================================================
from shopify.version import VERSION
from shopify.session import Session, ValidationException
from shopify.resources import *
from shopify.limits import Limits
from shopify.api_version import *
from shopify.api_access import *
from shopify.collection import PaginatedIterator


================================================
File: shopify/api_access.py
================================================
import re
import sys


def basestring_type():
    if sys.version_info[0] < 3:  # Backwards compatibility for python < v3.0.0
        return basestring
    else:
        return str


class ApiAccessError(Exception):
    pass


class ApiAccess:
    SCOPE_DELIMITER = ","
    SCOPE_RE = re.compile(r"\A(?P<unauthenticated>unauthenticated_)?(write|read)_(?P<resource>.*)\Z")
    IMPLIED_SCOPE_RE = re.compile(r"\A(?P<unauthenticated>unauthenticated_)?write_(?P<resource>.*)\Z")

    def __init__(self, scopes):
        if isinstance(scopes, basestring_type()):
            scopes = scopes.split(self.SCOPE_DELIMITER)

        self.__store_scopes(scopes)

    def covers(self, api_access):
        return api_access._compressed_scopes <= self._expanded_scopes

    def __str__(self):
        return self.SCOPE_DELIMITER.join(self._compressed_scopes)

    def __iter__(self):
        return iter(self._compressed_scopes)

    def __eq__(self, other):
        return type(self) == type(other) and self._compressed_scopes == other._compressed_scopes

    def __store_scopes(self, scopes):
        sanitized_scopes = frozenset(filter(None, [scope.strip() for scope in scopes]))
        self.__validate_scopes(sanitized_scopes)
        implied_scopes = frozenset(self.__implied_scope(scope) for scope in sanitized_scopes)
        self._compressed_scopes = sanitized_scopes - implied_scopes
        self._expanded_scopes = sanitized_scopes.union(implied_scopes)

    def __validate_scopes(self, scopes):
        for scope in scopes:
            if not self.SCOPE_RE.match(scope):
                error_message = "'{s}' is not a valid access scope".format(s=scope)
                raise ApiAccessError(error_message)

    def __implied_scope(self, scope):
        match = self.IMPLIED_SCOPE_RE.match(scope)
        if match:
            return "{unauthenticated}read_{resource}".format(
                unauthenticated=match.group("unauthenticated") or "",
                resource=match.group("resource"),
            )


================================================
File: shopify/api_version.py
================================================
import re


class InvalidVersionError(Exception):
    pass


class VersionNotFoundError(Exception):
    pass


class ApiVersion(object):
    versions = {}

    @classmethod
    def coerce_to_version(cls, version):
        try:
            return cls.versions[version]
        except KeyError:
            # Dynamically create a new Release object if version string is not found
            if Release.FORMAT.match(version):
                return Release(version)
            raise VersionNotFoundError

    @classmethod
    def define_version(cls, version):
        cls.versions[version.name] = version
        return version

    @classmethod
    def define_known_versions(cls):
        cls.define_version(Unstable())
        cls.define_version(Release("2021-10"))
        cls.define_version(Release("2022-01"))
        cls.define_version(Release("2022-04"))
        cls.define_version(Release("2022-07"))
        cls.define_version(Release("2022-10"))
        cls.define_version(Release("2023-01"))
        cls.define_version(Release("2023-04"))
        cls.define_version(Release("2023-07"))
        cls.define_version(Release("2023-10"))
        cls.define_version(Release("2024-01"))
        cls.define_version(Release("2024-04"))
        cls.define_version(Release("2024-07"))
        cls.define_version(Release("2024-10"))

    @classmethod
    def clear_defined_versions(cls):
        cls.versions = {}

    @property
    def numeric_version(self):
        return self._numeric_version

    @property
    def name(self):
        return self._name

    def api_path(self, site):
        return site + self._path

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        return self.numeric_version == int(other.numeric_version)


class Release(ApiVersion):
    FORMAT = re.compile(r"^\d{4}-\d{2}$")
    API_PREFIX = "/admin/api"

    def __init__(self, version_number):
        if not self.FORMAT.match(version_number):
            raise InvalidVersionError
        self._name = version_number
        self._numeric_version = int(version_number.replace("-", ""))
        self._path = "%s/%s" % (self.API_PREFIX, version_number)

    @property
    def stable(self):
        return True


class Unstable(ApiVersion):
    def __init__(self):
        self._name = "unstable"
        self._numeric_version = 9000000
        self._path = "/admin/api/unstable"

    @property
    def stable(self):
        return False


ApiVersion.define_known_versions()


================================================
File: shopify/base.py
================================================
import pyactiveresource.connection
from pyactiveresource.activeresource import ActiveResource, ResourceMeta, formats
import shopify.yamlobjects
import shopify.mixins as mixins
import shopify
import threading
import sys
from six.moves import urllib
import six

from shopify.collection import PaginatedCollection
from pyactiveresource.collection import Collection

# Store the response from the last request in the connection object


class ShopifyConnection(pyactiveresource.connection.Connection):
    response = None

    def _open(self, *args, **kwargs):
        self.response = None
        try:
            self.response = super(ShopifyConnection, self)._open(*args, **kwargs)
        except pyactiveresource.connection.ConnectionError as err:
            self.response = err.response
            raise
        return self.response


# Inherit from pyactiveresource's metaclass in order to use ShopifyConnection


class ShopifyResourceMeta(ResourceMeta):
    @property
    def connection(cls):
        """HTTP connection for the current thread"""
        local = cls._threadlocal
        if not getattr(local, "connection", None):
            # Make sure these variables are no longer affected by other threads.
            local.user = cls.user
            local.password = cls.password
            local.site = cls.site
            local.timeout = cls.timeout
            local.headers = cls.headers
            local.format = cls.format
            local.version = cls.version
            local.url = cls.url
            if cls.site is None:
                raise ValueError("No shopify session is active")
            local.connection = ShopifyConnection(cls.site, cls.user, cls.password, cls.timeout, cls.format)
        return local.connection

    def get_user(cls):
        return getattr(cls._threadlocal, "user", ShopifyResource._user)

    def set_user(cls, value):
        cls._threadlocal.connection = None
        ShopifyResource._user = cls._threadlocal.user = value

    user = property(get_user, set_user, None, "The username for HTTP Basic Auth.")

    def get_password(cls):
        return getattr(cls._threadlocal, "password", ShopifyResource._password)

    def set_password(cls, value):
        cls._threadlocal.connection = None
        ShopifyResource._password = cls._threadlocal.password = value

    password = property(get_password, set_password, None, "The password for HTTP Basic Auth.")

    def get_site(cls):
        return getattr(cls._threadlocal, "site", ShopifyResource._site)

    def set_site(cls, value):
        cls._threadlocal.connection = None
        ShopifyResource._site = cls._threadlocal.site = value
        if value is not None:
            parts = urllib.parse.urlparse(value)
            host = parts.hostname
            if parts.port:
                host += ":" + str(parts.port)
            new_site = urllib.parse.urlunparse((parts.scheme, host, parts.path, "", "", ""))
            ShopifyResource._site = cls._threadlocal.site = new_site
            if parts.username:
                cls.user = urllib.parse.unquote(parts.username)
            if parts.password:
                cls.password = urllib.parse.unquote(parts.password)

    site = property(get_site, set_site, None, "The base REST site to connect to.")

    def get_timeout(cls):
        return getattr(cls._threadlocal, "timeout", ShopifyResource._timeout)

    def set_timeout(cls, value):
        cls._threadlocal.connection = None
        ShopifyResource._timeout = cls._threadlocal.timeout = value

    timeout = property(get_timeout, set_timeout, None, "Socket timeout for HTTP requests")

    def get_headers(cls):
        if not hasattr(cls._threadlocal, "headers"):
            cls._threadlocal.headers = ShopifyResource._headers.copy()
        return cls._threadlocal.headers

    def set_headers(cls, value):
        cls._threadlocal.headers = value

    headers = property(get_headers, set_headers, None, "The headers sent with HTTP requests")

    def get_format(cls):
        return getattr(cls._threadlocal, "format", ShopifyResource._format)

    def set_format(cls, value):
        cls._threadlocal.connection = None
        ShopifyResource._format = cls._threadlocal.format = value

    format = property(get_format, set_format, None, "Encoding used for request and responses")

    def get_prefix_source(cls):
        """Return the prefix source, by default derived from site."""
        try:
            return cls.override_prefix()
        except AttributeError:
            if hasattr(cls, "_prefix_source"):
                return cls.site + cls._prefix_source
            else:
                return cls.site

    def set_prefix_source(cls, value):
        """Set the prefix source, which will be rendered into the prefix."""
        cls._prefix_source = value

    prefix_source = property(get_prefix_source, set_prefix_source, None, "prefix for lookups for this type of object.")

    def get_version(cls):
        if hasattr(cls._threadlocal, "version") or ShopifyResource._version:
            return getattr(cls._threadlocal, "version", ShopifyResource._version)
        elif ShopifyResource._site is not None:
            return ShopifyResource._site.split("/")[-1]

    def set_version(cls, value):
        ShopifyResource._version = cls._threadlocal.version = value

    version = property(get_version, set_version, None, "Shopify Api Version")

    def get_url(cls):
        return getattr(cls._threadlocal, "url", ShopifyResource._url)

    def set_url(cls, value):
        ShopifyResource._url = cls._threadlocal.url = value

    url = property(get_url, set_url, None, "Base URL including protocol and shopify domain")


@six.add_metaclass(ShopifyResourceMeta)
class ShopifyResource(ActiveResource, mixins.Countable):
    _format = formats.JSONFormat
    _threadlocal = threading.local()
    _headers = {"User-Agent": "ShopifyPythonAPI/%s Python/%s" % (shopify.VERSION, sys.version.split(" ", 1)[0])}
    _version = None
    _url = None

    def __init__(self, attributes=None, prefix_options=None):
        if attributes is not None and prefix_options is None:
            prefix_options, attributes = self.__class__._split_options(attributes)
        return super(ShopifyResource, self).__init__(attributes, prefix_options)

    def is_new(self):
        return not self.id

    def _load_attributes_from_response(self, response):
        if response.body.strip():
            self._update(self.__class__.format.decode(response.body))

    @classmethod
    def activate_session(cls, session):
        cls.site = session.site
        cls.url = session.url
        cls.user = None
        cls.password = None
        cls.version = session.api_version.name
        cls.headers["X-Shopify-Access-Token"] = session.token

    @classmethod
    def clear_session(cls):
        cls.site = None
        cls.url = None
        cls.user = None
        cls.password = None
        cls.version = None
        cls.headers.pop("X-Shopify-Access-Token", None)

    @classmethod
    def find(cls, id_=None, from_=None, **kwargs):
        """Checks the resulting collection for pagination metadata."""
        collection = super(ShopifyResource, cls).find(id_=id_, from_=from_, **kwargs)
        if isinstance(collection, Collection) and "headers" in collection.metadata:
            return PaginatedCollection(collection, metadata={"resource_class": cls}, **kwargs)
        return collection


================================================
File: shopify/collection.py
================================================
from pyactiveresource.collection import Collection


class PaginatedCollection(Collection):
    """
    A subclass of Collection which allows cycling through pages of
    data through cursor-based pagination.

    :next_page_url contains a url for fetching the next page
    :previous_page_url contains a url for fetching the previous page

    You can use next_page_url and previous_page_url to fetch the next page
    of data by calling Resource.find(from_=page.next_page_url)
    """

    def __init__(self, *args, **kwargs):
        """If given a Collection object as an argument, inherit its metadata."""

        metadata = kwargs.pop("metadata", None)
        obj = args[0]
        if isinstance(obj, Collection):
            if metadata:
                metadata.update(obj.metadata)
            else:
                metadata = obj.metadata
            super(PaginatedCollection, self).__init__(obj, metadata=metadata)
        else:
            super(PaginatedCollection, self).__init__(metadata=metadata or {}, *args, **kwargs)

        if not ("resource_class" in self.metadata):
            raise AttributeError('Cursor-based pagination requires a "resource_class" attribute in the metadata.')

        self.metadata["pagination"] = self.__parse_pagination()
        self.next_page_url = self.metadata["pagination"].get("next", None)
        self.previous_page_url = self.metadata["pagination"].get("previous", None)

        self._next = None
        self._previous = None
        self._current_iter = None
        self._no_iter_next = kwargs.pop("no_iter_next", True)

    def __parse_pagination(self):
        if "headers" not in self.metadata:
            return {}

        values = self.metadata["headers"].get("Link", self.metadata["headers"].get("link", None))
        if values is None:
            return {}

        result = {}
        for value in values.split(", "):
            link, rel = value.split("; ")
            result[rel.split('"')[1]] = link[1:-1]
        return result

    def has_previous_page(self):
        """Returns true if the current page has any previous pages before it."""
        return bool(self.previous_page_url)

    def has_next_page(self):
        """Returns true if the current page has any pages beyond the current position."""
        return bool(self.next_page_url)

    def previous_page(self, no_cache=False):
        """Returns the previous page of items.

        Args:
            no_cache: If true the page will not be cached.
        Returns:
            A PaginatedCollection object with the new data set.
        """
        if self._previous:
            return self._previous
        elif not self.has_previous_page():
            raise IndexError("No previous page")
        return self.__fetch_page(self.previous_page_url, no_cache)

    def next_page(self, no_cache=False):
        """Returns the next page of items.

        Args:
            no_cache: If true the page will not be cached.
        Returns:
            A PaginatedCollection object with the new data set.
        """
        if self._next:
            return self._next
        elif not self.has_next_page():
            raise IndexError("No next page")
        return self.__fetch_page(self.next_page_url, no_cache)

    def __fetch_page(self, url, no_cache=False):
        next = self.metadata["resource_class"].find(from_=url)
        if not no_cache:
            self._next = next
            self._next._previous = self
        next._no_iter_next = self._no_iter_next
        return next

    def __iter__(self):
        """Iterates through all items, also fetching other pages."""
        for item in super(PaginatedCollection, self).__iter__():
            yield item

        if self._no_iter_next:
            return

        try:
            if not self._current_iter:
                self._current_iter = self
            self._current_iter = self.next_page()

            for item in self._current_iter:
                yield item
        except IndexError:
            return

    def __len__(self):
        """If fetched count all the pages."""

        if self._next:
            count = len(self._next)
        else:
            count = 0
        return count + super(PaginatedCollection, self).__len__()


class PaginatedIterator(object):
    """
    This class implements an iterator over paginated collections which aims to
    be more memory-efficient by not keeping more than one page in memory at a
    time.

    >>> from shopify import Product, PaginatedIterator
    >>> for page in PaginatedIterator(Product.find()):
    ...     for item in page:
    ...         do_something(item)
    ...
    # every page and the page items are iterated
    """

    def __init__(self, collection):
        if not isinstance(collection, PaginatedCollection):
            raise TypeError("PaginatedIterator expects a PaginatedCollection instance")
        self.collection = collection
        self.collection._no_iter_next = True

    def __iter__(self):
        """Iterate over pages, returning one page at a time."""
        current_page = self.collection
        while True:
            yield current_page
            try:
                current_page = current_page.next_page(no_cache=True)
            except IndexError:
                return


================================================
File: shopify/limits.py
================================================
import shopify


class Limits(object):
    """
    API Calls Limit
    https://help.shopify.com/en/api/getting-started/api-call-limit

    Conversion of lib/shopify_api/limits.rb
    """

    # num_requests_executed/max_requests
    # Eg: 1/40
    CREDIT_LIMIT_HEADER_PARAM = "X-Shopify-Shop-Api-Call-Limit"

    @classmethod
    def response(cls):
        if not shopify.Shop.connection.response:
            shopify.Shop.current()
        return shopify.Shop.connection.response

    @classmethod
    def api_credit_limit_param(cls):
        response = cls.response()
        _safe_header = getattr(response, "headers", "")

        if not _safe_header:
            raise Exception("No shopify headers found")

        if cls.CREDIT_LIMIT_HEADER_PARAM in response.headers:
            credits = response.headers[cls.CREDIT_LIMIT_HEADER_PARAM]
            return credits.split("/")
        else:
            raise Exception("No valid api call header found")

    @classmethod
    def credit_left(cls):
        """
        How many more API calls can I make?
        """
        return int(cls.credit_limit() - cls.credit_used())

    @classmethod
    def credit_maxed(cls):
        """
        Have I reached my API call limit?
        """
        return bool(cls.credit_left() <= 0)

    @classmethod
    def credit_limit(cls):
        """
        How many total API calls can I make?
        """
        return int(cls.api_credit_limit_param()[1])

    @classmethod
    def credit_used(cls):
        """
        How many API calls have I made?
        """
        return int(cls.api_credit_limit_param()[0])


================================================
File: shopify/mixins.py
================================================
import shopify.resources


class Countable(object):
    @classmethod
    def count(cls, _options=None, **kwargs):
        if _options is None:
            _options = kwargs
        return int(cls.get("count", **_options))


class Metafields(object):
    def metafields(self, _options=None, **kwargs):
        if _options is None:
            _options = kwargs
        return shopify.resources.Metafield.find(resource=self.__class__.plural, resource_id=self.id, **_options)

    def metafields_count(self, _options=None, **kwargs):
        if _options is None:
            _options = kwargs
        return int(self.get("metafields/count", **_options))

    def add_metafield(self, metafield):
        if self.is_new():
            raise ValueError("You can only add metafields to a resource that has been saved")

        metafield._prefix_options = {"resource": self.__class__.plural, "resource_id": self.id}
        metafield.save()
        return metafield


class Events(object):
    def events(self):
        return shopify.resources.Event.find(resource=self.__class__.plural, resource_id=self.id)


================================================
File: shopify/session.py
================================================
import time
import hmac
import json
from hashlib import sha256

try:
    import simplejson as json
except ImportError:
    import json
import re
from contextlib import contextmanager
from six.moves import urllib
from shopify.api_access import ApiAccess
from shopify.api_version import ApiVersion, Release, Unstable
import six


class ValidationException(Exception):
    pass


class Session(object):
    api_key = None
    secret = None
    protocol = "https"
    myshopify_domain = "myshopify.com"
    port = None

    @classmethod
    def setup(cls, **kwargs):
        for k, v in six.iteritems(kwargs):
            setattr(cls, k, v)

    @classmethod
    @contextmanager
    def temp(cls, domain, version, token):
        import shopify

        original_domain = shopify.ShopifyResource.url
        original_token = shopify.ShopifyResource.get_headers().get("X-Shopify-Access-Token")
        original_version = shopify.ShopifyResource.get_version() or version
        original_session = shopify.Session(original_domain, original_version, original_token)

        session = Session(domain, version, token)
        shopify.ShopifyResource.activate_session(session)
        yield
        shopify.ShopifyResource.activate_session(original_session)

    def __init__(self, shop_url, version=None, token=None, access_scopes=None):
        self.url = self.__prepare_url(shop_url)
        self.token = token
        self.version = ApiVersion.coerce_to_version(version)
        self.access_scopes = access_scopes
        return

    def create_permission_url(self, redirect_uri, scope=None, state=None):
        query_params = {"client_id": self.api_key, "redirect_uri": redirect_uri}
        # `scope` should be omitted if provided by app's TOML
        if scope:
            query_params["scope"] = ",".join(scope)
        if state:
            query_params["state"] = state
        return "https://%s/admin/oauth/authorize?%s" % (self.url, urllib.parse.urlencode(query_params))

    def request_token(self, params):
        if self.token:
            return self.token

        if not self.validate_params(params):
            raise ValidationException("Invalid HMAC: Possibly malicious login")

        code = params["code"]

        url = "https://%s/admin/oauth/access_token?" % self.url
        query_params = {"client_id": self.api_key, "client_secret": self.secret, "code": code}
        request = urllib.request.Request(url, urllib.parse.urlencode(query_params).encode("utf-8"))
        response = urllib.request.urlopen(request)

        if response.code == 200:
            json_payload = json.loads(response.read().decode("utf-8"))
            self.token = json_payload["access_token"]
            self.access_scopes = json_payload["scope"]

            return self.token
        else:
            raise Exception(response.msg)

    @property
    def api_version(self):
        return self.version

    @property
    def site(self):
        return self.version.api_path("%s://%s" % (self.protocol, self.url))

    @property
    def valid(self):
        return self.url is not None and self.token is not None

    @property
    def access_scopes(self):
        return self._access_scopes

    @access_scopes.setter
    def access_scopes(self, scopes):
        if scopes is None or type(scopes) == ApiAccess:
            self._access_scopes = scopes
        else:
            self._access_scopes = ApiAccess(scopes)

    @classmethod
    def __prepare_url(cls, url):
        if not url or (url.strip() == ""):
            return None
        url = re.sub("^https?://", "", url)
        shop = urllib.parse.urlparse("https://" + url).hostname
        if shop is None:
            return None
        idx = shop.find(".")
        if idx != -1:
            shop = shop[0:idx]
        if len(shop) == 0:
            return None
        shop += "." + cls.myshopify_domain
        if cls.port:
            shop += ":" + str(cls.port)
        return shop

    @classmethod
    def validate_params(cls, params):
        # Avoid replay attacks by making sure the request
        # isn't more than a day old.
        one_day = 24 * 60 * 60
        if int(params.get("timestamp", 0)) < time.time() - one_day:
            return False

        return cls.validate_hmac(params)

    @classmethod
    def validate_hmac(cls, params):
        if "hmac" not in params:
            return False

        hmac_calculated = cls.calculate_hmac(params).encode("utf-8")
        hmac_to_verify = params["hmac"].encode("utf-8")

        # Try to use compare_digest() to reduce vulnerability to timing attacks.
        # If it's not available, just fall back to regular string comparison.
        try:
            return hmac.compare_digest(hmac_calculated, hmac_to_verify)
        except AttributeError:
            return hmac_calculated == hmac_to_verify

    @classmethod
    def calculate_hmac(cls, params):
        """
        Calculate the HMAC of the given parameters in line with Shopify's rules for OAuth authentication.
        See http://docs.shopify.com/api/authentication/oauth#verification.
        """
        encoded_params = cls.__encoded_params_for_signature(params)
        # Generate the hex digest for the sorted parameters using the secret.
        return hmac.new(cls.secret.encode(), encoded_params.encode(), sha256).hexdigest()

    @classmethod
    def __encoded_params_for_signature(cls, params):
        """
        Sort and combine query parameters into a single string, excluding those that should be removed and joining with '&'
        """

        def encoded_pairs(params):
            for k, v in six.iteritems(params):
                if k == "hmac":
                    continue

                if k.endswith("[]"):
                    # foo[]=1&foo[]=2 has to be transformed as foo=["1", "2"] note the whitespace after comma
                    k = k.rstrip("[]")
                    v = json.dumps(list(map(str, v)))

                # escape delimiters to avoid tampering
                k = str(k).replace("%", "%25").replace("=", "%3D")
                v = str(v).replace("%", "%25")
                yield "{0}={1}".format(k, v).replace("&", "%26")

        return "&".join(sorted(encoded_pairs(params)))


================================================
File: shopify/session_token.py
================================================
import jwt
import re
import six
import sys

from shopify.utils import shop_url

if sys.version_info[0] < 3:  # Backwards compatibility for python < v3.0.0
    from urlparse import urljoin
else:
    from urllib.parse import urljoin


ALGORITHM = "HS256"
PREFIX = "Bearer "
REQUIRED_FIELDS = ["iss", "dest", "sub", "jti", "sid"]
LEEWAY_SECONDS = 10


class SessionTokenError(Exception):
    pass


class InvalidIssuerError(SessionTokenError):
    pass


class MismatchedHostsError(SessionTokenError):
    pass


class TokenAuthenticationError(SessionTokenError):
    pass


def decode_from_header(authorization_header, api_key, secret):
    session_token = _extract_session_token(authorization_header)
    decoded_payload = _decode_session_token(session_token, api_key, secret)
    _validate_issuer(decoded_payload)

    return decoded_payload


def _extract_session_token(authorization_header):
    if not authorization_header.startswith(PREFIX):
        raise TokenAuthenticationError("The HTTP_AUTHORIZATION_HEADER provided does not contain a Bearer token")

    return authorization_header[len(PREFIX) :]


def _decode_session_token(session_token, api_key, secret):
    try:
        return jwt.decode(
            session_token,
            secret,
            audience=api_key,
            algorithms=[ALGORITHM],
            # AppBridge frequently sends future `nbf`, and it causes `ImmatureSignatureError`.
            # Accept few seconds clock skew to avoid this error.
            leeway=LEEWAY_SECONDS,
            options={"require": REQUIRED_FIELDS},
        )
    except jwt.exceptions.PyJWTError as exception:
        six.raise_from(SessionTokenError(str(exception)), exception)


def _validate_issuer(decoded_payload):
    _validate_issuer_hostname(decoded_payload)
    _validate_issuer_and_dest_match(decoded_payload)


def _validate_issuer_hostname(decoded_payload):
    issuer_root = urljoin(decoded_payload["iss"], "/")

    if not shop_url.sanitize_shop_domain(issuer_root):
        raise InvalidIssuerError("Invalid issuer")


def _validate_issuer_and_dest_match(decoded_payload):
    issuer_root = urljoin(decoded_payload["iss"], "/")
    dest_root = urljoin(decoded_payload["dest"], "/")

    if issuer_root != dest_root:
        raise MismatchedHostsError("The issuer and destination do not match")


================================================
File: shopify/version.py
================================================
VERSION = "12.7.1"


================================================
File: shopify/yamlobjects.py
================================================
try:
    # Shopify serializes receipts in YAML format, and yaml.safe_load will
    # not automatically load custom types because of security purpose,
    # so create safe loaders for types returned from Shopify here.
    #
    # The YAMLObject metaclass will automatically add these classes to
    # the list of constructors for yaml.safe_load to use.
    import yaml

    class YAMLHashWithIndifferentAccess(yaml.YAMLObject):
        yaml_tag = "!map:ActiveSupport::HashWithIndifferentAccess"
        yaml_loader = yaml.SafeLoader

        @classmethod
        def from_yaml(cls, loader, node):
            return loader.construct_mapping(node, cls)

except ImportError:
    pass


================================================
File: shopify/resources/__init__.py
================================================
from .shop import Shop
from .product import Product
from .cart import Cart
from .checkout import Checkout
from .custom_collection import CustomCollection
from .collect import Collect
from .shipping_address import ShippingAddress
from .billing_address import BillingAddress
from .line_item import LineItem
from .shipping_line import ShippingLine
from .note_attribute import NoteAttribute
from .address import Address
from .option import Option
from .payment_details import PaymentDetails
from .receipt import Receipt
from .rule import Rule
from .tax_line import TaxLine
from .script_tag import ScriptTag
from .application_charge import ApplicationCharge
from .application_credit import ApplicationCredit
from .recurring_application_charge import RecurringApplicationCharge
from .usage_charge import UsageCharge
from .asset import Asset
from .theme import Theme
from .currency import Currency
from .customer_saved_search import CustomerSavedSearch
from .customer_group import CustomerGroup
from .customer_invite import CustomerInvite
from .customer import Customer
from .event import Event
from .webhook import Webhook
from .redirect import Redirect
from .province import Province
from .comment import Comment
from .metafield import Metafield
from .article import Article
from .blog import Blog
from .page import Page
from .country import Country
from .refund import Refund
from .fulfillment import Fulfillment, FulfillmentOrders, FulfillmentV2
from .fulfillment_event import FulfillmentEvent
from .fulfillment_service import FulfillmentService
from .carrier_service import CarrierService
from .transaction import Transaction
from .tender_transaction import TenderTransaction
from .image import Image
from .variant import Variant
from .order import Order
from .balance import Balance
from .disputes import Disputes
from .payouts import Payouts
from .transactions import Transactions
from .order_risk import OrderRisk
from .policy import Policy
from .smart_collection import SmartCollection
from .gift_card import GiftCard
from .gift_card_adjustment import GiftCardAdjustment
from .shipping_zone import ShippingZone
from .location import Location
from .draft_order import DraftOrder
from .draft_order_invoice import DraftOrderInvoice
from .report import Report
from .price_rule import PriceRule
from .discount_code import DiscountCode
from .discount_code_creation import DiscountCodeCreation
from .marketing_event import MarketingEvent
from .collection_listing import CollectionListing
from .product_listing import ProductListing
from .resource_feedback import ResourceFeedback
from .storefront_access_token import StorefrontAccessToken
from .inventory_item import InventoryItem
from .inventory_level import InventoryLevel
from .access_scope import AccessScope
from .user import User
from .api_permission import ApiPermission
from .publication import Publication
from .collection_publication import CollectionPublication
from .product_publication import ProductPublication
from .graphql import GraphQL

from ..base import ShopifyResource


================================================
File: shopify/resources/access_scope.py
================================================
from ..base import ShopifyResource


class AccessScope(ShopifyResource):
    @classmethod
    def override_prefix(cls):
        return "/admin/oauth"


================================================
File: shopify/resources/address.py
================================================
from ..base import ShopifyResource


class Address(ShopifyResource):
    pass


================================================
File: shopify/resources/api_permission.py
================================================
from ..base import ShopifyResource


class ApiPermission(ShopifyResource):
    @classmethod
    def delete(cls):
        cls.connection.delete(cls.site + "/api_permissions/current." + cls.format.extension, cls.headers)

    destroy = delete


================================================
File: shopify/resources/application_charge.py
================================================
from ..base import ShopifyResource


class ApplicationCharge(ShopifyResource):
    def activate(self):
        self._load_attributes_from_response(self.post("activate"))


================================================
File: shopify/resources/application_credit.py
================================================
from ..base import ShopifyResource


class ApplicationCredit(ShopifyResource):
    pass


================================================
File: shopify/resources/article.py
================================================
from ..base import ShopifyResource
from shopify import mixins
from .comment import Comment


class Article(ShopifyResource, mixins.Metafields, mixins.Events):
    _prefix_source = "/blogs/$blog_id/"

    @classmethod
    def _prefix(cls, options={}):
        blog_id = options.get("blog_id")
        if blog_id:
            return "%s/blogs/%s" % (cls.site, blog_id)
        else:
            return cls.site

    def comments(self):
        return Comment.find(article_id=self.id)

    @classmethod
    def authors(cls, **kwargs):
        return cls.get("authors", **kwargs)

    @classmethod
    def tags(cls, **kwargs):
        return cls.get("tags", **kwargs)


================================================
File: shopify/resources/asset.py
================================================
from ..base import ShopifyResource
import base64


class Asset(ShopifyResource):
    _primary_key = "key"
    _prefix_source = "/themes/$theme_id/"

    @classmethod
    def _prefix(cls, options={}):
        theme_id = options.get("theme_id")
        if theme_id:
            return "%s/themes/%s" % (cls.site, theme_id)
        else:
            return cls.site

    @classmethod
    def _element_path(cls, id, prefix_options={}, query_options=None):
        if query_options is None:
            prefix_options, query_options = cls._split_options(prefix_options)
        return "%s%s.%s%s" % (
            cls._prefix(prefix_options) + "/",
            cls.plural,
            cls.format.extension,
            cls._query_string(query_options),
        )

    @classmethod
    def find(cls, key=None, **kwargs):
        """
        Find an asset by key
        E.g.
            shopify.Asset.find('layout/theme.liquid', theme_id=99)
        """
        if not key:
            return super(Asset, cls).find(**kwargs)

        params = {"asset[key]": key}
        params.update(kwargs)
        theme_id = params.get("theme_id")
        path_prefix = "%s/themes/%s" % (cls.site, theme_id) if theme_id else cls.site

        resource = cls.find_one("%s/assets.%s" % (path_prefix, cls.format.extension), **params)

        if theme_id and resource:
            resource._prefix_options["theme_id"] = theme_id
        return resource

    def __get_value(self):
        data = self.attributes.get("value")
        if data:
            return data
        data = self.attributes.get("attachment")
        if data:
            return base64.b64decode(data).decode()

    def __set_value(self, data):
        self.__wipe_value_attributes()
        self.attributes["value"] = data

    value = property(__get_value, __set_value, None, "The asset's value or attachment")

    def attach(self, data):
        self.attachment = base64.b64encode(data).decode()

    def destroy(self):
        options = {"asset[key]": self.key}
        options.update(self._prefix_options)
        return self.__class__.connection.delete(self._element_path(self.key, options), self.__class__.headers)

    def is_new(self):
        return False

    def __setattr__(self, name, value):
        if name in ("value", "attachment", "src", "source_key"):
            self.__wipe_value_attributes()
        return super(Asset, self).__setattr__(name, value)

    def __wipe_value_attributes(self):
        for attr in ("value", "attachment", "src", "source_key"):
            if attr in self.attributes:
                del self.attributes[attr]


================================================
File: shopify/resources/balance.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Balance(ShopifyResource, mixins.Metafields):
    _prefix_source = "/shopify_payments/"
    _singular = _plural = "balance"


================================================
File: shopify/resources/billing_address.py
================================================
from ..base import ShopifyResource


class BillingAddress(ShopifyResource):
    pass


================================================
File: shopify/resources/blog.py
================================================
from ..base import ShopifyResource
from shopify import mixins
import shopify


class Blog(ShopifyResource, mixins.Metafields, mixins.Events):
    def articles(self):
        return shopify.Article.find(blog_id=self.id)


================================================
File: shopify/resources/carrier_service.py
================================================
from ..base import ShopifyResource


class CarrierService(ShopifyResource):
    def __get_format(self):
        return self.attributes.get("format")

    def __set_format(self, data):
        self.attributes["format"] = data

    format = property(__get_format, __set_format, None, "Format attribute")


================================================
File: shopify/resources/cart.py
================================================
from ..base import ShopifyResource


class Cart(ShopifyResource):
    pass


================================================
File: shopify/resources/checkout.py
================================================
from ..base import ShopifyResource


class Checkout(ShopifyResource):
    pass


================================================
File: shopify/resources/collect.py
================================================
from ..base import ShopifyResource


class Collect(ShopifyResource):
    pass


================================================
File: shopify/resources/collection_listing.py
================================================
from ..base import ShopifyResource


class CollectionListing(ShopifyResource):
    _primary_key = "collection_id"

    def product_ids(cls, **kwargs):
        return cls.get("product_ids", **kwargs)


================================================
File: shopify/resources/collection_publication.py
================================================
from ..base import ShopifyResource


class CollectionPublication(ShopifyResource):
    _prefix_source = "/publications/$publication_id/"


================================================
File: shopify/resources/comment.py
================================================
from ..base import ShopifyResource


class Comment(ShopifyResource):
    def remove(self):
        self._load_attributes_from_response(self.post("remove"))

    def spam(self):
        self._load_attributes_from_response(self.post("spam"))

    def approve(self):
        self._load_attributes_from_response(self.post("approve"))

    def restore(self):
        self._load_attributes_from_response(self.post("restore"))

    def not_spam(self):
        self._load_attributes_from_response(self.post("not_spam"))


================================================
File: shopify/resources/country.py
================================================
from ..base import ShopifyResource


class Country(ShopifyResource):
    pass


================================================
File: shopify/resources/currency.py
================================================
from ..base import ShopifyResource


class Currency(ShopifyResource):
    pass


================================================
File: shopify/resources/custom_collection.py
================================================
from ..base import ShopifyResource
from shopify import mixins
import shopify


class CustomCollection(ShopifyResource, mixins.Metafields, mixins.Events):
    def products(self):
        return shopify.Product.find(collection_id=self.id)

    def add_product(self, product):
        return shopify.Collect.create({"collection_id": self.id, "product_id": product.id})

    def remove_product(self, product):
        collect = shopify.Collect.find_first(collection_id=self.id, product_id=product.id)
        if collect:
            collect.destroy()


================================================
File: shopify/resources/customer.py
================================================
from ..base import ShopifyResource
from shopify import mixins
from .customer_invite import CustomerInvite
from .order import Order


class Customer(ShopifyResource, mixins.Metafields):
    @classmethod
    def search(cls, **kwargs):
        """
        Search for customers matching supplied query

        Args:
           order: Field and direction to order results by (default: last_order_date DESC)
           query: Text to search for customers
           page: Page to show (default: 1)
           limit: Amount of results (default: 50) (maximum: 250)
           fields: comma-separated list of fields to include in the response
        Returns:
           A Collection of customers.
        """
        return cls._build_collection(cls.get("search", **kwargs))

    def send_invite(self, customer_invite=CustomerInvite()):
        resource = self.post("send_invite", customer_invite.encode())
        return CustomerInvite(Customer.format.decode(resource.body))

    def orders(self):
        return Order.find(customer_id=self.id)


================================================
File: shopify/resources/customer_group.py
================================================
from .customer_saved_search import CustomerSavedSearch


class CustomerGroup(CustomerSavedSearch):
    pass


================================================
File: shopify/resources/customer_invite.py
================================================
from ..base import ShopifyResource


class CustomerInvite(ShopifyResource):
    pass


================================================
File: shopify/resources/customer_saved_search.py
================================================
from ..base import ShopifyResource
from .customer import Customer


class CustomerSavedSearch(ShopifyResource):
    def customers(cls, **kwargs):
        return Customer._build_collection(cls.get("customers", **kwargs))


================================================
File: shopify/resources/discount_code.py
================================================
from ..base import ShopifyResource


class DiscountCode(ShopifyResource):
    _prefix_source = "/price_rules/$price_rule_id/"


================================================
File: shopify/resources/discount_code_creation.py
================================================
from ..base import ShopifyResource
from .discount_code import DiscountCode


class DiscountCodeCreation(ShopifyResource):
    _prefix_source = "/price_rules/$price_rule_id/"

    def discount_codes(self):
        return DiscountCode.find(
            from_="%s/price_rules/%s/batch/%s/discount_codes.%s"
            % (
                ShopifyResource.site,
                self._prefix_options["price_rule_id"],
                self.id,
                DiscountCodeCreation.format.extension,
            )
        )


================================================
File: shopify/resources/disputes.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Disputes(ShopifyResource, mixins.Metafields):
    _prefix_source = "/shopify_payments/"


================================================
File: shopify/resources/draft_order.py
================================================
from ..base import ShopifyResource
from shopify import mixins
from .draft_order_invoice import DraftOrderInvoice


class DraftOrder(ShopifyResource, mixins.Metafields):
    def send_invoice(self, draft_order_invoice=DraftOrderInvoice()):
        resource = self.post("send_invoice", draft_order_invoice.encode())
        return DraftOrderInvoice(DraftOrder.format.decode(resource.body))

    def complete(self, params={}):
        if params.get("payment_pending", False):
            self._load_attributes_from_response(self.put("complete", payment_pending="true"))
        else:
            self._load_attributes_from_response(self.put("complete"))


================================================
File: shopify/resources/draft_order_invoice.py
================================================
from ..base import ShopifyResource


class DraftOrderInvoice(ShopifyResource):
    pass


================================================
File: shopify/resources/event.py
================================================
from ..base import ShopifyResource


class Event(ShopifyResource):
    _prefix_source = "/$resource/$resource_id/"

    @classmethod
    def _prefix(cls, options={}):
        resource = options.get("resource")
        if resource:
            return "%s/%s/%s" % (cls.site, resource, options["resource_id"])
        else:
            return cls.site


================================================
File: shopify/resources/fulfillment.py
================================================
from ..base import ShopifyResource
import json


class Fulfillment(ShopifyResource):
    _prefix_source = "/orders/$order_id/"

    def cancel(self):
        self._load_attributes_from_response(self.post("cancel"))

    def complete(self):
        self._load_attributes_from_response(self.post("complete"))

    def open(self):
        self._load_attributes_from_response(self.post("open"))

    def update_tracking(self, tracking_info, notify_customer):
        fulfill = FulfillmentV2()
        fulfill.id = self.id
        self._load_attributes_from_response(fulfill.update_tracking(tracking_info, notify_customer))


class FulfillmentOrders(ShopifyResource):
    _prefix_source = "/orders/$order_id/"


class FulfillmentV2(ShopifyResource):
    _singular = "fulfillment"
    _plural = "fulfillments"

    def update_tracking(self, tracking_info, notify_customer):
        body = {"fulfillment": {"tracking_info": tracking_info, "notify_customer": notify_customer}}
        return self.post("update_tracking", json.dumps(body).encode())


================================================
File: shopify/resources/fulfillment_event.py
================================================
from ..base import ShopifyResource


class FulfillmentEvent(ShopifyResource):
    _prefix_source = "/orders/$order_id/fulfillments/$fulfillment_id/"
    _singular = "event"
    _plural = "events"

    @classmethod
    def _prefix(cls, options={}):
        order_id = options.get("order_id")
        fulfillment_id = options.get("fulfillment_id")
        event_id = options.get("event_id")

        return "%s/orders/%s/fulfillments/%s" % (cls.site, order_id, fulfillment_id)

    def save(self):
        status = self.attributes["status"]
        if status not in [
            "label_printed",
            "label_purchased",
            "attempted_delivery",
            "ready_for_pickup",
            "picked_up",
            "confirmed",
            "in_transit",
            "out_for_delivery",
            "delivered",
            "failure",
        ]:
            raise AttributeError("Invalid status")
        return super(ShopifyResource, self).save()


================================================
File: shopify/resources/fulfillment_service.py
================================================
from ..base import ShopifyResource


class FulfillmentService(ShopifyResource):
    def __get_format(self):
        return self.attributes.get("format")

    def __set_format(self, data):
        self.attributes["format"] = data

    format = property(__get_format, __set_format, None, "Format attribute")


================================================
File: shopify/resources/gift_card.py
================================================
from ..base import ShopifyResource
from .gift_card_adjustment import GiftCardAdjustment


class GiftCard(ShopifyResource):
    def disable(self):
        self._load_attributes_from_response(self.post("disable"))

    @classmethod
    def search(cls, **kwargs):
        """
        Search for gift cards matching supplied query

        Args:
           order: Field and direction to order results by (default: disabled_at DESC)
           query: Text to search for gift cards
           page: Page to show (default: 1)
           limit: Amount of results (default: 50) (maximum: 250)
           fields: comma-separated list of fields to include in the response
        Returns:
           An array of gift cards.
        """
        return cls._build_collection(cls.get("search", **kwargs))

    def add_adjustment(self, adjustment):
        """
        Create a new Gift Card Adjustment
        """
        resource = self.post("adjustments", adjustment.encode())
        return GiftCardAdjustment(GiftCard.format.decode(resource.body))


================================================
File: shopify/resources/gift_card_adjustment.py
================================================
from ..base import ShopifyResource


class GiftCardAdjustment(ShopifyResource):
    _prefix_source = "/admin/gift_cards/$gift_card_id/"
    _plural = "adjustments"
    _singular = "adjustment"


================================================
File: shopify/resources/graphql.py
================================================
import shopify
from ..base import ShopifyResource
from six.moves import urllib
import json


class GraphQL:
    def __init__(self):
        self.endpoint = shopify.ShopifyResource.get_site() + "/graphql.json"
        self.headers = shopify.ShopifyResource.get_headers()

    def merge_headers(self, *headers):
        merged_headers = {}
        for header in headers:
            merged_headers.update(header)
        return merged_headers

    def execute(self, query, variables=None, operation_name=None):
        endpoint = self.endpoint
        default_headers = {"Accept": "application/json", "Content-Type": "application/json"}
        headers = self.merge_headers(default_headers, self.headers)
        data = {"query": query, "variables": variables, "operationName": operation_name}

        req = urllib.request.Request(self.endpoint, json.dumps(data).encode("utf-8"), headers)

        try:
            response = urllib.request.urlopen(req)
            return response.read().decode("utf-8")
        except urllib.error.HTTPError as e:
            print((e.read()))
            print("")
            raise e


================================================
File: shopify/resources/image.py
================================================
from ..base import ShopifyResource
from ..resources import Metafield
from six.moves import urllib
import base64
import re


class Image(ShopifyResource):
    _prefix_source = "/products/$product_id/"

    @classmethod
    def _prefix(cls, options={}):
        product_id = options.get("product_id")
        if product_id:
            return "%s/products/%s" % (cls.site, product_id)
        else:
            return cls.site

    def __getattr__(self, name):
        if name in ["pico", "icon", "thumb", "small", "compact", "medium", "large", "grande", "original"]:
            return re.sub(r"/(.*)\.(\w{2,4})", r"/\1_%s.\2" % (name), self.src)
        else:
            return super(Image, self).__getattr__(name)

    def attach_image(self, data, filename=None):
        self.attributes["attachment"] = base64.b64encode(data).decode()
        if filename:
            self.attributes["filename"] = filename

    def metafields(self):
        if self.is_new():
            return []
        query_params = {"metafield[owner_id]": self.id, "metafield[owner_resource]": "product_image"}
        return Metafield.find(
            from_="%s/metafields.json?%s" % (ShopifyResource.site, urllib.parse.urlencode(query_params))
        )

    def save(self):
        if "product_id" not in self._prefix_options:
            self._prefix_options["product_id"] = self.product_id
        return super(ShopifyResource, self).save()


================================================
File: shopify/resources/inventory_item.py
================================================
from ..base import ShopifyResource


class InventoryItem(ShopifyResource):
    pass


================================================
File: shopify/resources/inventory_level.py
================================================
from ..base import ShopifyResource
import shopify
import json


class InventoryLevel(ShopifyResource):
    def __repr__(self):
        return "%s(inventory_item_id=%s, location_id=%s)" % (self._singular, self.inventory_item_id, self.location_id)

    @classmethod
    def _element_path(cls, prefix_options={}, query_options=None):
        if query_options is None:
            prefix_options, query_options = cls._split_options(prefix_options)

        return "%s%s.%s%s" % (
            cls._prefix(prefix_options) + "/",
            cls.plural,
            cls.format.extension,
            cls._query_string(query_options),
        )

    @classmethod
    def adjust(cls, location_id, inventory_item_id, available_adjustment):
        body = {
            "inventory_item_id": inventory_item_id,
            "location_id": location_id,
            "available_adjustment": available_adjustment,
        }
        resource = cls.post("adjust", body=json.dumps(body).encode())
        return InventoryLevel(InventoryLevel.format.decode(resource.body))

    @classmethod
    def connect(cls, location_id, inventory_item_id, relocate_if_necessary=False, **kwargs):
        body = {
            "inventory_item_id": inventory_item_id,
            "location_id": location_id,
            "relocate_if_necessary": relocate_if_necessary,
        }
        resource = cls.post("connect", body=json.dumps(body).encode())
        return InventoryLevel(InventoryLevel.format.decode(resource.body))

    @classmethod
    def set(cls, location_id, inventory_item_id, available, disconnect_if_necessary=False, **kwargs):
        body = {
            "inventory_item_id": inventory_item_id,
            "location_id": location_id,
            "available": available,
            "disconnect_if_necessary": disconnect_if_necessary,
        }
        resource = cls.post("set", body=json.dumps(body).encode())
        return InventoryLevel(InventoryLevel.format.decode(resource.body))

    def is_new(self):
        return False

    def destroy(self):
        options = {"inventory_item_id": self.inventory_item_id, "location_id": self.location_id}
        return self.__class__.connection.delete(self._element_path(query_options=options), self.__class__.headers)


================================================
File: shopify/resources/line_item.py
================================================
from ..base import ShopifyResource


class LineItem(ShopifyResource):
    class Property(ShopifyResource):
        pass


================================================
File: shopify/resources/location.py
================================================
from ..base import ShopifyResource
from .inventory_level import InventoryLevel


class Location(ShopifyResource):
    def inventory_levels(self, **kwargs):
        return InventoryLevel.find(
            from_="%s/locations/%s/inventory_levels.json" % (ShopifyResource.site, self.id), **kwargs
        )


================================================
File: shopify/resources/marketing_event.py
================================================
import json
from ..base import ShopifyResource


class MarketingEvent(ShopifyResource):
    def add_engagements(self, engagements):
        engagements_json = json.dumps({"engagements": engagements})
        return self.post("engagements", engagements_json.encode())


================================================
File: shopify/resources/metafield.py
================================================
from ..base import ShopifyResource


class Metafield(ShopifyResource):
    _prefix_source = "/$resource/$resource_id/"

    @classmethod
    def _prefix(cls, options={}):
        resource = options.get("resource")
        if resource:
            return "%s/%s/%s" % (cls.site, resource, options["resource_id"])
        else:
            return cls.site


================================================
File: shopify/resources/note_attribute.py
================================================
from ..base import ShopifyResource


class NoteAttribute(ShopifyResource):
    pass


================================================
File: shopify/resources/option.py
================================================
from ..base import ShopifyResource


class Option(ShopifyResource):
    pass


================================================
File: shopify/resources/order.py
================================================
from ..base import ShopifyResource
from shopify import mixins
from .transaction import Transaction


class Order(ShopifyResource, mixins.Metafields, mixins.Events):
    _prefix_source = "/customers/$customer_id/"

    @classmethod
    def _prefix(cls, options={}):
        customer_id = options.get("customer_id")
        if customer_id:
            return "%s/customers/%s" % (cls.site, customer_id)
        else:
            return cls.site

    def close(self):
        self._load_attributes_from_response(self.post("close"))

    def open(self):
        self._load_attributes_from_response(self.post("open"))

    def cancel(self, **kwargs):
        self._load_attributes_from_response(self.post("cancel", **kwargs))

    def transactions(self):
        return Transaction.find(order_id=self.id)

    def capture(self, amount=""):
        return Transaction.create({"amount": amount, "kind": "capture", "order_id": self.id})


================================================
File: shopify/resources/order_risk.py
================================================
from ..base import ShopifyResource


class OrderRisk(ShopifyResource):
    _prefix_source = "/orders/$order_id/"
    _singular = "risk"
    _plural = "risks"


================================================
File: shopify/resources/page.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Page(ShopifyResource, mixins.Metafields, mixins.Events):
    pass


================================================
File: shopify/resources/payment_details.py
================================================
from ..base import ShopifyResource


class PaymentDetails(ShopifyResource):
    pass


================================================
File: shopify/resources/payouts.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Payouts(ShopifyResource, mixins.Metafields):
    _prefix_source = "/shopify_payments/"


================================================
File: shopify/resources/policy.py
================================================
from ..base import ShopifyResource
from shopify import mixins
import shopify


class Policy(ShopifyResource, mixins.Metafields, mixins.Events):
    pass


================================================
File: shopify/resources/price_rule.py
================================================
import json
from ..base import ShopifyResource
from .discount_code import DiscountCode
from .discount_code_creation import DiscountCodeCreation


class PriceRule(ShopifyResource):
    def add_discount_code(self, discount_code=DiscountCode()):
        resource = self.post("discount_codes", discount_code.encode())
        return DiscountCode(PriceRule.format.decode(resource.body))

    def discount_codes(self):
        return DiscountCode.find(price_rule_id=self.id)

    def create_batch(self, codes=[]):
        codes_json = json.dumps({"discount_codes": codes})

        response = self.post("batch", codes_json.encode())
        return DiscountCodeCreation(PriceRule.format.decode(response.body))

    def find_batch(self, batch_id):
        return DiscountCodeCreation.find_one(
            "%s/price_rules/%s/batch/%s.%s" % (ShopifyResource.site, self.id, batch_id, PriceRule.format.extension)
        )


================================================
File: shopify/resources/product.py
================================================
from ..base import ShopifyResource
from shopify import mixins
import shopify


class Product(ShopifyResource, mixins.Metafields, mixins.Events):
    def price_range(self):
        prices = [float(variant.price) for variant in self.variants]
        f = "%0.2f"
        min_price = min(prices)
        max_price = max(prices)
        if min_price != max_price:
            return "%s - %s" % (f % min_price, f % max_price)
        else:
            return f % min_price

    def collections(self):
        return shopify.CustomCollection.find(product_id=self.id)

    def smart_collections(self):
        return shopify.SmartCollection.find(product_id=self.id)

    def add_to_collection(self, collection):
        return collection.add_product(self)

    def remove_from_collection(self, collection):
        return collection.remove_product(self)

    def add_variant(self, variant):
        variant.attributes["product_id"] = self.id
        return variant.save()

    def save(self):
        start_api_version = "201910"
        api_version = ShopifyResource.version
        if api_version and (api_version.strip("-") >= start_api_version) and api_version != "unstable":
            if "variants" in self.attributes:
                for variant in self.variants:
                    if "inventory_quantity" in variant.attributes:
                        del variant.attributes["inventory_quantity"]
                    if "old_inventory_quantity" in variant.attributes:
                        del variant.attributes["old_inventory_quantity"]
        return super(ShopifyResource, self).save()


================================================
File: shopify/resources/product_listing.py
================================================
from ..base import ShopifyResource


class ProductListing(ShopifyResource):
    _primary_key = "product_id"

    @classmethod
    def product_ids(cls, **kwargs):
        return cls.get("product_ids", **kwargs)


================================================
File: shopify/resources/product_publication.py
================================================
from ..base import ShopifyResource


class ProductPublication(ShopifyResource):
    _prefix_source = "/publications/$publication_id/"


================================================
File: shopify/resources/province.py
================================================
from ..base import ShopifyResource


class Province(ShopifyResource):
    _prefix_source = "/admin/countries/$country_id/"


================================================
File: shopify/resources/publication.py
================================================
from ..base import ShopifyResource


class Publication(ShopifyResource):
    pass


================================================
File: shopify/resources/receipt.py
================================================
from ..base import ShopifyResource


class Receipt(ShopifyResource):
    pass


================================================
File: shopify/resources/recurring_application_charge.py
================================================
from ..base import ShopifyResource
from .usage_charge import UsageCharge


def _get_first_by_status(resources, status):
    for resource in resources:
        if resource.status == status:
            return resource
    return None


class RecurringApplicationCharge(ShopifyResource):
    def usage_charges(self):
        return UsageCharge.find(recurring_application_charge_id=self.id)

    def customize(self, **kwargs):
        self._load_attributes_from_response(self.put("customize", recurring_application_charge=kwargs))

    @classmethod
    def current(cls):
        """
        Returns first RecurringApplicationCharge object with status=active.
        If not found, None will be returned.
        """
        return _get_first_by_status(cls.find(), "active")

    def activate(self):
        self._load_attributes_from_response(self.post("activate"))


================================================
File: shopify/resources/redirect.py
================================================
from ..base import ShopifyResource


class Redirect(ShopifyResource):
    pass


================================================
File: shopify/resources/refund.py
================================================
import json

from ..base import ShopifyResource


class Refund(ShopifyResource):
    _prefix_source = "/orders/$order_id/"

    @classmethod
    def calculate(cls, order_id, shipping=None, refund_line_items=None):
        """
        Calculates refund transactions based on line items and shipping.
        When you want to create a refund, you should first use the calculate
        endpoint to generate accurate refund transactions.

        Args:
           order_id: Order ID for which the Refund has to created.
           shipping: Specify how much shipping to refund.
           refund_line_items: A list of line item IDs and quantities to refund.
        Returns:
           Unsaved refund record
        """
        data = {}
        if shipping:
            data["shipping"] = shipping
        data["refund_line_items"] = refund_line_items or []
        body = {"refund": data}
        resource = cls.post("calculate", order_id=order_id, body=json.dumps(body).encode())
        return cls(cls.format.decode(resource.body), prefix_options={"order_id": order_id})


================================================
File: shopify/resources/report.py
================================================
from ..base import ShopifyResource


class Report(ShopifyResource):
    pass


================================================
File: shopify/resources/resource_feedback.py
================================================
from ..base import ShopifyResource


class ResourceFeedback(ShopifyResource):
    _prefix_source = "/products/$product_id/"
    _plural = "resource_feedback"

    @classmethod
    def _prefix(cls, options={}):
        product_id = options.get("product_id")
        if product_id:
            return "%s/products/%s" % (cls.site, product_id)
        else:
            return cls.site


================================================
File: shopify/resources/rule.py
================================================
from ..base import ShopifyResource


class Rule(ShopifyResource):
    pass


================================================
File: shopify/resources/script_tag.py
================================================
from ..base import ShopifyResource


class ScriptTag(ShopifyResource):
    pass


================================================
File: shopify/resources/shipping_address.py
================================================
from ..base import ShopifyResource


class ShippingAddress(ShopifyResource):
    pass


================================================
File: shopify/resources/shipping_line.py
================================================
from ..base import ShopifyResource


class ShippingLine(ShopifyResource):
    pass


================================================
File: shopify/resources/shipping_zone.py
================================================
from ..base import ShopifyResource


class ShippingZone(ShopifyResource):
    pass


================================================
File: shopify/resources/shop.py
================================================
from ..base import ShopifyResource
from .metafield import Metafield
from .event import Event


class Shop(ShopifyResource):
    @classmethod
    def current(cls):
        return cls.find_one(cls.site + "/shop." + cls.format.extension)

    def metafields(self):
        return Metafield.find()

    def add_metafield(self, metafield):
        if self.is_new():
            raise ValueError("You can only add metafields to a resource that has been saved")
        metafield.save()
        return metafield

    def events(self):
        return Event.find()


================================================
File: shopify/resources/smart_collection.py
================================================
from ..base import ShopifyResource
from shopify import mixins
import shopify


class SmartCollection(ShopifyResource, mixins.Metafields, mixins.Events):
    def products(self):
        return shopify.Product.find(collection_id=self.id)


================================================
File: shopify/resources/storefront_access_token.py
================================================
from ..base import ShopifyResource


class StorefrontAccessToken(ShopifyResource):
    pass


================================================
File: shopify/resources/tax_line.py
================================================
from ..base import ShopifyResource


class TaxLine(ShopifyResource):
    pass


================================================
File: shopify/resources/tender_transaction.py
================================================
from ..base import ShopifyResource


class TenderTransaction(ShopifyResource):
    pass


================================================
File: shopify/resources/theme.py
================================================
from ..base import ShopifyResource


class Theme(ShopifyResource):
    pass


================================================
File: shopify/resources/transaction.py
================================================
from ..base import ShopifyResource


class Transaction(ShopifyResource):
    _prefix_source = "/orders/$order_id/"


================================================
File: shopify/resources/transactions.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Transactions(ShopifyResource, mixins.Metafields):
    _prefix_source = "/shopify_payments/balance/"


================================================
File: shopify/resources/usage_charge.py
================================================
from ..base import ShopifyResource


class UsageCharge(ShopifyResource):
    _prefix_source = "/recurring_application_charge/$recurring_application_charge_id/"

    @classmethod
    def _prefix(cls, options={}):
        recurring_application_charge_id = options.get("recurring_application_charge_id")
        if recurring_application_charge_id:
            return "%s/recurring_application_charges/%s" % (cls.site, recurring_application_charge_id)
        else:
            return cls.site


================================================
File: shopify/resources/user.py
================================================
from ..base import ShopifyResource


class User(ShopifyResource):
    @classmethod
    def current(cls):
        return User(cls.get("current"))


================================================
File: shopify/resources/variant.py
================================================
from ..base import ShopifyResource
from shopify import mixins


class Variant(ShopifyResource, mixins.Metafields):
    _prefix_source = "/products/$product_id/"

    @classmethod
    def _prefix(cls, options={}):
        product_id = options.get("product_id")
        if product_id:
            return "%s/products/%s" % (cls.site, product_id)
        else:
            return cls.site

    def save(self):
        if "product_id" not in self._prefix_options:
            self._prefix_options["product_id"] = self.product_id

        start_api_version = "201910"
        api_version = ShopifyResource.version
        if api_version and (api_version.strip("-") >= start_api_version) and api_version != "unstable":
            if "inventory_quantity" in self.attributes:
                del self.attributes["inventory_quantity"]
            if "old_inventory_quantity" in self.attributes:
                del self.attributes["old_inventory_quantity"]

        return super(ShopifyResource, self).save()


================================================
File: shopify/resources/webhook.py
================================================
from ..base import ShopifyResource


class Webhook(ShopifyResource):
    def __get_format(self):
        return self.attributes.get("format")

    def __set_format(self, data):
        self.attributes["format"] = data

    format = property(__get_format, __set_format, None, "Format attribute")


================================================
File: shopify/utils/shop_url.py
================================================
import re
import sys

if sys.version_info[0] < 3:  # Backwards compatibility for python < v3.0.0
    from urlparse import urlparse
else:
    from urllib.parse import urlparse

HOSTNAME_PATTERN = r"[a-z0-9][a-z0-9-]*[a-z0-9]"


def sanitize_shop_domain(shop_domain, myshopify_domain="myshopify.com"):
    name = str(shop_domain or "").lower().strip()
    if myshopify_domain not in name and "." not in name:
        name += ".{domain}".format(domain=myshopify_domain)
    name = re.sub(r"https?://", "", name)

    uri = urlparse("http://{hostname}".format(hostname=name))
    if re.match(r"{h}\.{d}$".format(h=HOSTNAME_PATTERN, d=re.escape(myshopify_domain)), uri.netloc):
        return uri.netloc


================================================
File: test/access_scope_test.py
================================================
import shopify
from test.test_helper import TestCase


class AccessScopeTest(TestCase):
    def test_find_should_return_all_access_scopes(self):
        self.fake("oauth/access_scopes", body=self.load_fixture("access_scopes"), prefix="/admin")
        scopes = shopify.AccessScope.find()
        self.assertEqual(3, len(scopes))
        self.assertEqual("read_products", scopes[0].handle)


================================================
File: test/api_access_test.py
================================================
from shopify import ApiAccess, ApiAccessError
from test.test_helper import TestCase


class ApiAccessTest(TestCase):
    def test_creating_scopes_from_a_string_works_with_a_comma_separated_list(self):
        deserialized_read_products_write_orders = ApiAccess("read_products,write_orders")
        serialized_read_products_write_orders = str(deserialized_read_products_write_orders)
        expected_read_products_write_orders = ApiAccess(["read_products", "write_orders"])

        self.assertEqual(expected_read_products_write_orders, ApiAccess(serialized_read_products_write_orders))

    def test_creating_api_access_from_invalid_scopes_raises(self):
        with self.assertRaises(ApiAccessError) as cm:
            api_access = ApiAccess("bad_scope, read_orders,write_orders")

        self.assertEqual("'bad_scope' is not a valid access scope", str(cm.exception))

    def test_returns_list_of_reduced_scopes(self):
        api_access = ApiAccess("read_products, read_orders,write_orders")
        expected_scopes = set(["read_products", "write_orders"])
        scopes = list(api_access)

        self.assertEqual(expected_scopes, set(scopes))

    def test_write_is_the_same_access_as_read_write_on_the_same_resource(self):
        read_write_orders = ApiAccess(["read_orders", "write_orders"])
        write_orders = ApiAccess("write_orders")

        self.assertEqual(write_orders, read_write_orders)

    def test_write_is_the_same_access_as_read_write_on_the_same_unauthenticated_resource(self):
        unauthenticated_read_write_orders = ApiAccess(["unauthenticated_read_orders", "unauthenticated_write_orders"])
        unauthenticated_write_orders = ApiAccess("unauthenticated_write_orders")

        self.assertEqual(unauthenticated_write_orders, unauthenticated_read_write_orders)

    def test_read_is_not_the_same_as_read_write_on_the_same_resource(self):
        read_orders = ApiAccess("read_orders")
        read_write_orders = ApiAccess(["write_orders", "read_orders"])

        self.assertNotEqual(read_write_orders, read_orders)

    def test_two_different_resources_are_not_equal(self):
        read_orders = ApiAccess("read_orders")
        read_products = ApiAccess("read_products")

        self.assertNotEqual(read_orders, read_products)

    def test_two_identical_scopes_are_equal(self):
        read_orders = ApiAccess("read_orders")
        read_orders_identical = ApiAccess("read_orders")

        self.assertEqual(read_orders, read_orders_identical)

    def test_unauthenticated_is_not_implied_by_authenticated_access(self):
        unauthenticated_orders = ApiAccess("unauthenticated_read_orders")
        authenticated_read_orders = ApiAccess("read_orders")
        authenticated_write_orders = ApiAccess("write_orders")

        self.assertNotEqual(unauthenticated_orders, authenticated_read_orders)
        self.assertNotEqual(unauthenticated_orders, authenticated_write_orders)

    def test_scopes_covers_is_truthy_for_same_scopes(self):
        read_orders = ApiAccess("read_orders")
        read_orders_identical = ApiAccess("read_orders")

        self.assertTrue(read_orders.covers(read_orders_identical))

    def test_covers_is_falsy_for_different_scopes(self):
        read_orders = ApiAccess("read_orders")
        read_products = ApiAccess("read_products")

        self.assertFalse(read_orders.covers(read_products))

    def test_covers_is_truthy_for_read_when_the_set_has_read_write(self):
        write_products = ApiAccess("write_products")
        read_products = ApiAccess("read_products")

        self.assertTrue(write_products.covers(read_products))

    def test_covers_is_truthy_for_read_when_the_set_has_read_write_for_that_resource_and_others(self):
        write_products_and_orders = ApiAccess(["write_products", "write_orders"])
        read_orders = ApiAccess("read_orders")

        self.assertTrue(write_products_and_orders.covers(read_orders))

    def test_covers_is_truthy_for_write_when_the_set_has_read_write_for_that_resource_and_others(self):
        write_products_and_orders = ApiAccess(["write_products", "write_orders"])
        write_orders = ApiAccess("write_orders")

        self.assertTrue(write_products_and_orders.covers(write_orders))

    def test_covers_is_truthy_for_subset_of_scopes(self):
        write_products_orders_customers = ApiAccess(["write_products", "write_orders", "write_customers"])
        write_orders_products = ApiAccess(["write_orders", "read_products"])

        self.assertTrue(write_products_orders_customers.covers(write_orders_products))

    def test_covers_is_falsy_for_sets_of_scopes_that_have_no_common_elements(self):
        write_products_orders_customers = ApiAccess(["write_products", "write_orders", "write_customers"])
        write_images_read_content = ApiAccess(["write_images", "read_content"])

        self.assertFalse(write_products_orders_customers.covers(write_images_read_content))

    def test_covers_is_falsy_for_sets_of_scopes_that_have_only_some_common_access(self):
        write_products_orders_customers = ApiAccess(["write_products", "write_orders", "write_customers"])
        write_products_read_content = ApiAccess(["write_products", "read_content"])

        self.assertFalse(write_products_orders_customers.covers(write_products_read_content))

    def test_duplicate_scopes_resolve_to_one_scope(self):
        read_orders_duplicated = ApiAccess(["read_orders", "read_orders", "read_orders", "read_orders"])
        read_orders = ApiAccess("read_orders")

        self.assertEqual(read_orders, read_orders_duplicated)

    def test_to_s_outputs_scopes_as_a_comma_separated_list_without_implied_read_scopes(self):
        serialized_read_products_write_orders = "read_products,write_orders"
        read_products_write_orders = ApiAccess(["read_products", "read_orders", "write_orders"])

        self.assertIn("read_products", str(read_products_write_orders))
        self.assertIn("write_orders", str(read_products_write_orders))

    def test_to_a_outputs_scopes_as_an_array_of_strings_without_implied_read_scopes(self):
        serialized_read_products_write_orders = ["write_orders", "read_products"]
        read_products_write_orders = ApiAccess(["read_products", "read_orders", "write_orders"])

        self.assertEqual(set(serialized_read_products_write_orders), set(list(read_products_write_orders)))

    def test_creating_scopes_removes_extra_whitespace_from_scope_name_and_blank_scope_names(self):
        deserialized_read_products_write_orders = ApiAccess([" read_products", "  ", "write_orders "])
        serialized_read_products_write_orders = str(deserialized_read_products_write_orders)
        expected_read_products_write_orders = ApiAccess(["read_products", "write_orders"])

        self.assertEqual(expected_read_products_write_orders, ApiAccess(serialized_read_products_write_orders))

    def test_creating_scopes_from_a_string_works_with_a_comma_separated_list(self):
        deserialized_read_products_write_orders = ApiAccess("read_products,write_orders")
        serialized_read_products_write_orders = str(deserialized_read_products_write_orders)
        expected_read_products_write_orders = ApiAccess(["read_products", "write_orders"])

        self.assertEqual(expected_read_products_write_orders, ApiAccess(serialized_read_products_write_orders))

    def test_using_to_s_from_one_scopes_to_construct_another_will_be_equal(self):
        read_products_write_orders = ApiAccess(["read_products", "write_orders"])

        self.assertEqual(read_products_write_orders, ApiAccess(str(read_products_write_orders)))

    def test_using_to_a_from_one_scopes_to_construct_another_will_be_equal(self):
        read_products_write_orders = ApiAccess(["read_products", "write_orders"])

        self.assertEqual(read_products_write_orders, ApiAccess(list(read_products_write_orders)))


================================================
File: test/api_permission_test.py
================================================
import shopify
from test.test_helper import TestCase


class ApiPermissionTest(TestCase):
    def test_delete_api_permission(self):
        self.fake("api_permissions/current", method="DELETE", code=200, body="{}")

        shopify.ApiPermission.delete()


================================================
File: test/api_version_test.py
================================================
import shopify
from test.test_helper import TestCase


class ApiVersionTest(TestCase):
    """
    Api Version Tests
    """

    def tearDown(self):
        shopify.ApiVersion.clear_defined_versions()
        shopify.ApiVersion.define_known_versions()

    def test_unstable_api_path_returns_correct_url(self):
        self.assertEqual(
            "https://fakeshop.myshopify.com/admin/api/unstable",
            shopify.Unstable().api_path("https://fakeshop.myshopify.com"),
        )

    def test_coerce_to_version_returns_known_versions(self):
        v1 = shopify.Unstable()
        v2 = shopify.ApiVersion.define_version(shopify.Release("2019-01"))

        self.assertNotEqual(v1, None)
        self.assertEqual(v1, shopify.ApiVersion.coerce_to_version("unstable"))
        self.assertEqual(v2, shopify.ApiVersion.coerce_to_version("2019-01"))

    def test_coerce_to_version_raises_with_string_that_does_not_match_known_version(self):
        with self.assertRaises(shopify.VersionNotFoundError):
            shopify.ApiVersion.coerce_to_version("crazy-name")

    def test_coerce_to_version_creates_new_release_on_the_fly(self):
        new_version = "2025-01"
        coerced_version = shopify.ApiVersion.coerce_to_version(new_version)

        self.assertIsInstance(coerced_version, shopify.Release)
        self.assertEqual(coerced_version.name, new_version)
        self.assertEqual(
            coerced_version.api_path("https://test.myshopify.com"),
            f"https://test.myshopify.com/admin/api/{new_version}",
        )

        # Verify that the new version is not added to the known versions
        self.assertNotIn(new_version, shopify.ApiVersion.versions)


class ReleaseTest(TestCase):
    def test_raises_if_format_invalid(self):
        with self.assertRaises(shopify.InvalidVersionError):
            shopify.Release("crazy-name")

    def test_release_api_path_returns_correct_url(self):
        self.assertEqual(
            "https://fakeshop.myshopify.com/admin/api/2019-04",
            shopify.Release("2019-04").api_path("https://fakeshop.myshopify.com"),
        )

    def test_two_release_versions_with_same_number_are_equal(self):
        version1 = shopify.Release("2019-01")
        version2 = shopify.Release("2019-01")
        self.assertEqual(version1, version2)


================================================
File: test/application_credit_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class ApplicationCreditTest(TestCase):
    def test_get_application_credit(self):
        self.fake("application_credits/445365009", method="GET", body=self.load_fixture("application_credit"), code=200)
        application_credit = shopify.ApplicationCredit.find(445365009)
        self.assertEqual("5.00", application_credit.amount)

    def test_get_all_application_credits(self):
        self.fake("application_credits", method="GET", body=self.load_fixture("application_credits"), code=200)
        application_credits = shopify.ApplicationCredit.find()
        self.assertEqual(1, len(application_credits))
        self.assertEqual(445365009, application_credits[0].id)

    def test_create_application_credit(self):
        self.fake(
            "application_credits",
            method="POST",
            body=self.load_fixture("application_credit"),
            headers={"Content-type": "application/json"},
            code=201,
        )

        application_credit = shopify.ApplicationCredit.create(
            {"description": "application credit for refund", "amount": 5.0}
        )

        expected_body = {"application_credit": {"description": "application credit for refund", "amount": 5.0}}

        self.assertEqual(expected_body, json.loads(self.http.request.data.decode("utf-8")))


================================================
File: test/article_test.py
================================================
import shopify
from test.test_helper import TestCase


class ArticleTest(TestCase):
    def test_create_article(self):
        self.fake(
            "blogs/1008414260/articles",
            method="POST",
            body=self.load_fixture("article"),
            headers={"Content-type": "application/json"},
        )
        article = shopify.Article({"blog_id": 1008414260})
        article.save()
        self.assertEqual("First Post", article.title)

    def test_get_article(self):
        self.fake("articles/6242736", method="GET", body=self.load_fixture("article"))
        article = shopify.Article.find(6242736)
        self.assertEqual("First Post", article.title)

    def test_update_article(self):
        self.fake("articles/6242736", method="GET", body=self.load_fixture("article"))
        article = shopify.Article.find(6242736)

        self.fake(
            "articles/6242736",
            method="PUT",
            body=self.load_fixture("article"),
            headers={"Content-type": "application/json"},
        )
        article.save()

    def test_get_articles(self):
        self.fake("articles", method="GET", body=self.load_fixture("articles"))
        articles = shopify.Article.find()
        self.assertEqual(3, len(articles))

    def test_get_articles_namespaced(self):
        self.fake("blogs/1008414260/articles", method="GET", body=self.load_fixture("articles"))
        articles = shopify.Article.find(blog_id=1008414260)
        self.assertEqual(3, len(articles))

    def test_get_article_namespaced(self):
        self.fake("blogs/1008414260/articles/6242736", method="GET", body=self.load_fixture("article"))
        article = shopify.Article.find(6242736, blog_id=1008414260)
        self.assertEqual("First Post", article.title)

    def test_get_authors(self):
        self.fake("articles/authors", method="GET", body=self.load_fixture("authors"))
        authors = shopify.Article.authors()
        self.assertEqual("Shopify", authors[0])
        self.assertEqual("development shop", authors[-1])

    def test_get_authors_for_blog_id(self):
        self.fake("blogs/1008414260/articles/authors", method="GET", body=self.load_fixture("authors"))
        authors = shopify.Article.authors(blog_id=1008414260)
        self.assertEqual(3, len(authors))

    def test_get_tags(self):
        self.fake("articles/tags", method="GET", body=self.load_fixture("tags"))
        tags = shopify.Article.tags()
        self.assertEqual("consequuntur", tags[0])
        self.assertEqual("repellendus", tags[-1])

    def test_get_tags_for_blog_id(self):
        self.fake("blogs/1008414260/articles/tags", method="GET", body=self.load_fixture("tags"))
        tags = shopify.Article.tags(blog_id=1008414260)
        self.assertEqual("consequuntur", tags[0])
        self.assertEqual("repellendus", tags[-1])

    def test_get_popular_tags(self):
        self.fake("articles/tags.json?limit=1&popular=1", extension=False, method="GET", body=self.load_fixture("tags"))
        tags = shopify.Article.tags(popular=1, limit=1)
        self.assertEqual(3, len(tags))


================================================
File: test/asset_test.py
================================================
import base64

import shopify
from test.test_helper import TestCase


class AssetTest(TestCase):
    def test_get_assets(self):
        self.fake("assets", method="GET", body=self.load_fixture("assets"))
        v = shopify.Asset.find()

    def test_get_asset(self):
        self.fake(
            "assets.json?asset%5Bkey%5D=templates%2Findex.liquid",
            extension=False,
            method="GET",
            body=self.load_fixture("asset"),
        )
        v = shopify.Asset.find("templates/index.liquid")

    def test_update_asset(self):
        self.fake(
            "assets.json?asset%5Bkey%5D=templates%2Findex.liquid",
            extension=False,
            method="GET",
            body=self.load_fixture("asset"),
        )
        v = shopify.Asset.find("templates/index.liquid")

        self.fake("assets", method="PUT", body=self.load_fixture("asset"), headers={"Content-type": "application/json"})
        v.save()

    def test_get_assets_namespaced(self):
        self.fake("themes/1/assets", method="GET", body=self.load_fixture("assets"))
        v = shopify.Asset.find(theme_id=1)

    def test_get_asset_namespaced(self):
        self.fake(
            "themes/1/assets.json?asset%5Bkey%5D=templates%2Findex.liquid&theme_id=1",
            extension=False,
            method="GET",
            body=self.load_fixture("asset"),
        )
        v = shopify.Asset.find("templates/index.liquid", theme_id=1)

    def test_update_asset_namespaced(self):
        self.fake(
            "themes/1/assets.json?asset%5Bkey%5D=templates%2Findex.liquid&theme_id=1",
            extension=False,
            method="GET",
            body=self.load_fixture("asset"),
        )
        v = shopify.Asset.find("templates/index.liquid", theme_id=1)

        self.fake(
            "themes/1/assets",
            method="PUT",
            body=self.load_fixture("asset"),
            headers={"Content-type": "application/json"},
        )
        v.save()

    def test_delete_asset_namespaced(self):
        self.fake(
            "themes/1/assets.json?asset%5Bkey%5D=templates%2Findex.liquid&theme_id=1",
            extension=False,
            method="GET",
            body=self.load_fixture("asset"),
        )
        v = shopify.Asset.find("templates/index.liquid", theme_id=1)

        self.fake(
            "themes/1/assets.json?asset%5Bkey%5D=templates%2Findex.liquid", extension=False, method="DELETE", body="{}"
        )
        v.destroy()

    def test_attach(self):
        self.fake(
            "themes/1/assets",
            method="PUT",
            body=self.load_fixture("asset"),
            headers={"Content-type": "application/json"},
        )
        attachment = b"dGVzdCBiaW5hcnkgZGF0YTogAAE="
        key = "assets/test.jpeg"
        theme_id = 1
        asset = shopify.Asset({"key": key, "theme_id": theme_id})
        asset.attach(attachment)
        asset.save()
        self.assertEqual(base64.b64encode(attachment).decode(), asset.attributes["attachment"])


================================================
File: test/balance_test.py
================================================
import shopify
from test.test_helper import TestCase


class BalanceTest(TestCase):
    prefix = "/admin/api/unstable/shopify_payments"

    def test_get_balance(self):
        self.fake("balance", method="GET", prefix=self.prefix, body=self.load_fixture("balance"))
        balance = shopify.Balance.find()
        self.assertGreater(len(balance), 0)


================================================
File: test/base_test.py
================================================
import shopify
from test.test_helper import TestCase
from pyactiveresource.activeresource import ActiveResource
from mock import patch
import threading


class BaseTest(TestCase):
    @classmethod
    def setUpClass(self):
        shopify.ApiVersion.define_known_versions()
        shopify.ApiVersion.define_version(shopify.Release("2019-04"))
        self.session1 = shopify.Session("shop1.myshopify.com", "unstable", "token1")
        self.session2 = shopify.Session("shop2.myshopify.com", "2019-04", "token2")

    @classmethod
    def tearDownClass(self):
        shopify.ApiVersion.clear_defined_versions()

    def tearDown(self):
        shopify.ShopifyResource.clear_session()

    def test_activate_session_should_set_site_and_headers_for_given_session(self):
        shopify.ShopifyResource.activate_session(self.session1)

        self.assertIsNone(ActiveResource.site)
        self.assertEqual("https://shop1.myshopify.com/admin/api/unstable", shopify.ShopifyResource.site)
        self.assertEqual("https://shop1.myshopify.com/admin/api/unstable", shopify.Shop.site)
        self.assertIsNone(ActiveResource.headers)
        self.assertEqual("token1", shopify.ShopifyResource.headers["X-Shopify-Access-Token"])
        self.assertEqual("token1", shopify.Shop.headers["X-Shopify-Access-Token"])

    def test_activate_session_should_set_site_given_version(self):
        shopify.ShopifyResource.activate_session(self.session2)

        self.assertIsNone(ActiveResource.site)
        self.assertEqual("https://shop2.myshopify.com/admin/api/2019-04", shopify.ShopifyResource.site)
        self.assertEqual("https://shop2.myshopify.com/admin/api/2019-04", shopify.Shop.site)
        self.assertIsNone(ActiveResource.headers)

    def test_clear_session_should_clear_site_and_headers_from_base(self):
        shopify.ShopifyResource.activate_session(self.session1)
        shopify.ShopifyResource.clear_session()

        self.assertIsNone(ActiveResource.site)
        self.assertIsNone(shopify.ShopifyResource.site)
        self.assertIsNone(shopify.Shop.site)

        self.assertIsNone(ActiveResource.headers)
        self.assertFalse("X-Shopify-Access-Token" in shopify.ShopifyResource.headers)
        self.assertFalse("X-Shopify-Access-Token" in shopify.Shop.headers)

    def test_activate_session_with_one_session_then_clearing_and_activating_with_another_session_shoul_request_to_correct_shop(
        self,
    ):
        shopify.ShopifyResource.activate_session(self.session1)
        shopify.ShopifyResource.clear_session()
        shopify.ShopifyResource.activate_session(self.session2)

        self.assertIsNone(ActiveResource.site)
        self.assertEqual("https://shop2.myshopify.com/admin/api/2019-04", shopify.ShopifyResource.site)
        self.assertEqual("https://shop2.myshopify.com/admin/api/2019-04", shopify.Shop.site)

        self.assertIsNone(ActiveResource.headers)
        self.assertEqual("token2", shopify.ShopifyResource.headers["X-Shopify-Access-Token"])
        self.assertEqual("token2", shopify.Shop.headers["X-Shopify-Access-Token"])

    def test_delete_should_send_custom_headers_with_request(self):
        shopify.ShopifyResource.activate_session(self.session1)

        org_headers = shopify.ShopifyResource.headers
        shopify.ShopifyResource.set_headers({"X-Custom": "abc"})

        with patch("shopify.ShopifyResource.connection.delete") as mock:
            url = shopify.ShopifyResource._custom_method_collection_url("1", {})
            shopify.ShopifyResource.delete("1")
            mock.assert_called_with(url, {"X-Custom": "abc"})

        shopify.ShopifyResource.set_headers(org_headers)

    def test_headers_includes_user_agent(self):
        self.assertTrue("User-Agent" in shopify.ShopifyResource.headers)
        t = threading.Thread(target=lambda: self.assertTrue("User-Agent" in shopify.ShopifyResource.headers))
        t.start()
        t.join()

    def test_headers_is_thread_safe(self):
        def testFunc():
            shopify.ShopifyResource.headers["X-Custom"] = "abc"
            self.assertTrue("X-Custom" in shopify.ShopifyResource.headers)

        t1 = threading.Thread(target=testFunc)
        t1.start()
        t1.join()

        t2 = threading.Thread(target=lambda: self.assertFalse("X-Custom" in shopify.ShopifyResource.headers))
        t2.start()
        t2.join()

    def test_setting_with_user_and_pass_strips_them(self):
        shopify.ShopifyResource.clear_session()
        self.fake(
            "shop",
            url="https://this-is-my-test-show.myshopify.com/admin/shop.json",
            method="GET",
            body=self.load_fixture("shop"),
            headers={"Authorization": "Basic dXNlcjpwYXNz"},
        )
        API_KEY = "user"
        PASSWORD = "pass"
        shop_url = "https://%s:%s@this-is-my-test-show.myshopify.com/admin" % (API_KEY, PASSWORD)
        shopify.ShopifyResource.set_site(shop_url)
        res = shopify.Shop.current()
        self.assertEqual("Apple Computers", res.name)


================================================
File: test/blog_test.py
================================================
import shopify
from test.test_helper import TestCase


class BlogTest(TestCase):
    def test_blog_creation(self):
        self.fake(
            "blogs",
            method="POST",
            code=202,
            body=self.load_fixture("blog"),
            headers={"Content-type": "application/json"},
        )
        blog = shopify.Blog.create({"title": "Test Blog"})
        self.assertEqual("Test Blog", blog.title)


================================================
File: test/carrier_service_test.py
================================================
import shopify
from test.test_helper import TestCase


class CarrierServiceTest(TestCase):
    def test_create_new_carrier_service(self):
        self.fake(
            "carrier_services",
            method="POST",
            body=self.load_fixture("carrier_service"),
            headers={"Content-type": "application/json"},
        )

        carrier_service = shopify.CarrierService.create({"name": "Some Postal Service"})
        self.assertEqual("Some Postal Service", carrier_service.name)

    def test_get_carrier_service(self):
        self.fake("carrier_services/123456", method="GET", body=self.load_fixture("carrier_service"))

        carrier_service = shopify.CarrierService.find(123456)
        self.assertEqual("Some Postal Service", carrier_service.name)

    def test_set_format_attribute(self):
        carrier_service = shopify.CarrierService()
        carrier_service.format = "json"
        self.assertEqual("json", carrier_service.attributes["format"])


================================================
File: test/cart_test.py
================================================
import shopify
from test.test_helper import TestCase


class CartTest(TestCase):
    def test_all_should_return_all_carts(self):
        self.fake("carts")
        carts = shopify.Cart.find()
        self.assertEqual(2, len(carts))
        self.assertEqual(2, carts[0].id)
        self.assertEqual("3eed8183d4281db6ea82ee2b8f23e9cc", carts[0].token)
        self.assertEqual(1, len(carts[0].line_items))
        self.assertEqual("test", carts[0].line_items[0].title)


================================================
File: test/checkout_test.py
================================================
import shopify
from test.test_helper import TestCase


class CheckoutTest(TestCase):
    def test_all_should_return_all_checkouts(self):
        self.fake("checkouts")
        checkouts = shopify.Checkout.find()
        self.assertEqual(1, len(checkouts))
        self.assertEqual(450789469, checkouts[0].id)
        self.assertEqual("2a1ace52255252df566af0faaedfbfa7", checkouts[0].token)
        self.assertEqual(2, len(checkouts[0].line_items))


================================================
File: test/collection_listing_test.py
================================================
import shopify
from test.test_helper import TestCase


class CollectionListingTest(TestCase):
    def test_get_collection_listings(self):
        self.fake("collection_listings", method="GET", code=200, body=self.load_fixture("collection_listings"))

        collection_listings = shopify.CollectionListing.find()
        self.assertEqual(1, len(collection_listings))
        self.assertEqual(1, collection_listings[0].collection_id)
        self.assertEqual("Home page", collection_listings[0].title)

    def test_get_collection_listing(self):
        self.fake("collection_listings/1", method="GET", code=200, body=self.load_fixture("collection_listing"))

        collection_listing = shopify.CollectionListing.find(1)

        self.assertEqual(1, collection_listing.collection_id)
        self.assertEqual("Home page", collection_listing.title)

    def test_reload_collection_listing(self):
        self.fake("collection_listings/1", method="GET", code=200, body=self.load_fixture("collection_listing"))

        collection_listing = shopify.CollectionListing()
        collection_listing.collection_id = 1
        collection_listing.reload()

        self.assertEqual(1, collection_listing.collection_id)
        self.assertEqual("Home page", collection_listing.title)

    def test_get_collection_listing_product_ids(self):
        self.fake(
            "collection_listings/1/product_ids",
            method="GET",
            code=200,
            body=self.load_fixture("collection_listing_product_ids"),
        )

        collection_listing = shopify.CollectionListing()
        collection_listing.id = 1
        product_ids = collection_listing.product_ids()

        self.assertEqual([1, 2], product_ids)


================================================
File: test/collection_publication_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class CollectionPublicationTest(TestCase):
    def test_find_all_collection_publications(self):
        self.fake(
            "publications/55650051/collection_publications",
            method="GET",
            body=self.load_fixture("collection_publications"),
        )
        collection_publications = shopify.CollectionPublication.find(publication_id=55650051)

        self.assertEqual(96062799894, collection_publications[0].id)
        self.assertEqual(60941828118, collection_publications[0].collection_id)

    def test_find_collection_publication(self):
        self.fake(
            "publications/55650051/collection_publications/96062799894",
            method="GET",
            body=self.load_fixture("collection_publication"),
            code=200,
        )
        collection_publication = shopify.CollectionPublication.find(96062799894, publication_id=55650051)

        self.assertEqual(96062799894, collection_publication.id)
        self.assertEqual(60941828118, collection_publication.collection_id)

    def test_create_collection_publication(self):
        self.fake(
            "publications/55650051/collection_publications",
            method="POST",
            headers={"Content-type": "application/json"},
            body=self.load_fixture("collection_publication"),
            code=201,
        )

        collection_publication = shopify.CollectionPublication.create(
            {
                "publication_id": 55650051,
                "published_at": "2018-01-29T14:06:08-05:00",
                "published": True,
                "collection_id": 60941828118,
            }
        )

        expected_body = {
            "collection_publication": {
                "published_at": "2018-01-29T14:06:08-05:00",
                "published": True,
                "collection_id": 60941828118,
            }
        }

        self.assertEqual(expected_body, json.loads(self.http.request.data.decode("utf-8")))

    def test_destroy_collection_publication(self):
        self.fake(
            "publications/55650051/collection_publications/96062799894",
            method="GET",
            body=self.load_fixture("collection_publication"),
            code=200,
        )
        collection_publication = shopify.CollectionPublication.find(96062799894, publication_id=55650051)

        self.fake("publications/55650051/collection_publications/96062799894", method="DELETE", body="{}", code=200)
        collection_publication.destroy()

        self.assertEqual("DELETE", self.http.request.get_method())


================================================
File: test/currency_test.py
================================================
import shopify
from test.test_helper import TestCase


class CurrencyTest(TestCase):
    def test_get_currencies(self):
        self.fake("currencies", method="GET", code=200, body=self.load_fixture("currencies"))

        currencies = shopify.Currency.find()
        self.assertEqual(4, len(currencies))
        self.assertEqual("AUD", currencies[0].currency)
        self.assertEqual("2018-10-03T14:44:08-04:00", currencies[0].rate_updated_at)
        self.assertEqual(True, currencies[0].enabled)
        self.assertEqual("EUR", currencies[1].currency)
        self.assertEqual("2018-10-03T14:44:08-04:00", currencies[1].rate_updated_at)
        self.assertEqual(True, currencies[1].enabled)
        self.assertEqual("GBP", currencies[2].currency)
        self.assertEqual("2018-10-03T14:44:08-04:00", currencies[2].rate_updated_at)
        self.assertEqual(True, currencies[2].enabled)
        self.assertEqual("HKD", currencies[3].currency)
        self.assertEqual("2018-10-03T14:44:08-04:00", currencies[3].rate_updated_at)
        self.assertEqual(False, currencies[3].enabled)


================================================
File: test/customer_saved_search_test.py
================================================
import shopify
from test.test_helper import TestCase


class CustomerSavedSearchTest(TestCase):
    def setUp(self):
        super(CustomerSavedSearchTest, self).setUp()
        self.load_customer_saved_search()

    def test_get_customers_from_customer_saved_search(self):
        self.fake(
            "customer_saved_searches/8899730/customers", body=self.load_fixture("customer_saved_search_customers")
        )
        self.assertEqual(1, len(self.customer_saved_search.customers()))
        self.assertEqual(112223902, self.customer_saved_search.customers()[0].id)

    def test_get_customers_from_customer_saved_search_with_params(self):
        self.fake(
            "customer_saved_searches/8899730/customers.json?limit=1",
            extension=False,
            body=self.load_fixture("customer_saved_search_customers"),
        )
        customers = self.customer_saved_search.customers(limit=1)
        self.assertEqual(1, len(customers))
        self.assertEqual(112223902, customers[0].id)

    def load_customer_saved_search(self):
        self.fake("customer_saved_searches/8899730", body=self.load_fixture("customer_saved_search"))
        self.customer_saved_search = shopify.CustomerSavedSearch.find(8899730)


================================================
File: test/customer_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class CustomerTest(TestCase):
    def setUp(self):
        super(CustomerTest, self).setUp()
        self.fake("customers/207119551", method="GET", body=self.load_fixture("customer"))
        self.customer = shopify.Customer.find(207119551)

    def test_create_customer(self):
        self.fake(
            "customers", method="POST", body=self.load_fixture("customer"), headers={"Content-type": "application/json"}
        )
        customer = shopify.Customer()
        customer.first_name = "Bob"
        customer.last_name = "Lastnameson"
        customer.email = "steve.lastnameson@example.com"
        customer.verified_email = True
        customer.password = "newpass"
        customer.password_confirmation = "newpass"
        self.assertEqual("newpass", customer.attributes["password"])
        customer.save()
        self.assertEqual("Bob", customer.first_name)
        self.assertEqual("newpass", customer.attributes["password"])

    def test_get_customer(self):
        self.assertEqual("Bob", self.customer.first_name)

    def test_search(self):
        self.fake(
            "customers/search.json?query=Bob+country%3AUnited+States",
            extension=False,
            body=self.load_fixture("customers_search"),
        )

        results = shopify.Customer.search(query="Bob country:United States")
        self.assertEqual("Bob", results[0].first_name)

    def test_send_invite_with_no_params(self):
        customer_invite_fixture = self.load_fixture("customer_invite")
        customer_invite = json.loads(customer_invite_fixture.decode("utf-8"))
        self.fake(
            "customers/207119551/send_invite",
            method="POST",
            body=customer_invite_fixture,
            headers={"Content-type": "application/json"},
        )
        customer_invite_response = self.customer.send_invite()
        self.assertEqual(json.loads('{"customer_invite": {}}'), json.loads(self.http.request.data.decode("utf-8")))
        self.assertIsInstance(customer_invite_response, shopify.CustomerInvite)
        self.assertEqual(customer_invite["customer_invite"]["to"], customer_invite_response.to)

    def test_send_invite_with_params(self):
        customer_invite_fixture = self.load_fixture("customer_invite")
        customer_invite = json.loads(customer_invite_fixture.decode("utf-8"))
        self.fake(
            "customers/207119551/send_invite",
            method="POST",
            body=customer_invite_fixture,
            headers={"Content-type": "application/json"},
        )
        customer_invite_response = self.customer.send_invite(shopify.CustomerInvite(customer_invite["customer_invite"]))
        self.assertEqual(customer_invite, json.loads(self.http.request.data.decode("utf-8")))
        self.assertIsInstance(customer_invite_response, shopify.CustomerInvite)
        self.assertEqual(customer_invite["customer_invite"]["to"], customer_invite_response.to)

    def test_get_customer_orders(self):
        self.fake("customers/207119551", method="GET", body=self.load_fixture("customer"))
        customer = shopify.Customer.find(207119551)
        self.fake("customers/207119551/orders", method="GET", body=self.load_fixture("orders"))
        orders = customer.orders()
        self.assertIsInstance(orders[0], shopify.Order)
        self.assertEqual(450789469, orders[0].id)
        self.assertEqual(207119551, orders[0].customer.id)


================================================
File: test/discount_code_creation_test.py
================================================
from test.test_helper import TestCase
import shopify


class DiscountCodeCreationTest(TestCase):
    def test_find_batch_job_discount_codes(self):
        self.fake("price_rules/1213131", body=self.load_fixture("price_rule"))
        price_rule = shopify.PriceRule.find(1213131)

        self.fake("price_rules/1213131/batch/989355119", body=self.load_fixture("discount_code_creation"))
        batch = price_rule.find_batch(989355119)

        self.fake("price_rules/1213131/batch/989355119/discount_codes", body=self.load_fixture("batch_discount_codes"))
        discount_codes = batch.discount_codes()

        self.assertEqual("foo", discount_codes[0].code)
        self.assertEqual("bar", discount_codes[2].code)


================================================
File: test/discount_code_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class DiscountCodeTest(TestCase):
    def setUp(self):
        super(DiscountCodeTest, self).setUp()
        self.fake("price_rules/1213131/discount_codes/34", method="GET", body=self.load_fixture("discount_code"))
        self.discount_code = shopify.DiscountCode.find(34, price_rule_id=1213131)

    def test_find_a_specific_discount_code(self):
        discount_code = shopify.DiscountCode.find(34, price_rule_id=1213131)
        self.assertEqual("25OFF", discount_code.code)

    def test_update_a_specific_discount_code(self):
        self.discount_code.code = "BOGO"
        self.fake(
            "price_rules/1213131/discount_codes/34",
            method="PUT",
            code=200,
            body=self.load_fixture("discount_code"),
            headers={"Content-type": "application/json"},
        )
        self.discount_code.save()
        self.assertEqual("BOGO", json.loads(self.http.request.data.decode("utf-8"))["discount_code"]["code"])

    def test_delete_a_specific_discount_code(self):
        self.fake("price_rules/1213131/discount_codes/34", method="DELETE", body="destroyed")
        self.discount_code.destroy()
        self.assertEqual("DELETE", self.http.request.get_method())


================================================
File: test/disputes_test.py
================================================
import shopify
from test.test_helper import TestCase


class DisputeTest(TestCase):
    prefix = "/admin/api/unstable/shopify_payments"

    def test_get_dispute(self):
        self.fake("disputes", method="GET", prefix=self.prefix, body=self.load_fixture("disputes"))
        disputes = shopify.Disputes.find()
        self.assertGreater(len(disputes), 0)

    def test_get_one_dispute(self):
        self.fake("disputes/1052608616", method="GET", prefix=self.prefix, body=self.load_fixture("dispute"))
        disputes = shopify.Disputes.find(1052608616)
        self.assertEqual("won", disputes.status)


================================================
File: test/draft_order_test.py
================================================
import shopify
from test.test_helper import TestCase
import json


class DraftOrderTest(TestCase):
    def setUp(self):
        super(DraftOrderTest, self).setUp()
        self.fake("draft_orders/517119332", body=self.load_fixture("draft_order"))
        self.draft_order = shopify.DraftOrder.find(517119332)

    def test_get_draft_order(self):
        self.fake("draft_orders/517119332", method="GET", code=200, body=self.load_fixture("draft_order"))
        draft_order = shopify.DraftOrder.find(517119332)
        self.assertEqual(517119332, draft_order.id)

    def test_get_all_draft_orders(self):
        self.fake("draft_orders", method="GET", code=200, body=self.load_fixture("draft_orders"))
        draft_orders = shopify.DraftOrder.find()
        self.assertEqual(1, len(draft_orders))
        self.assertEqual(517119332, draft_orders[0].id)

    def test_get_count_draft_orders(self):
        self.fake("draft_orders/count", method="GET", code=200, body='{"count": 16}')
        draft_orders_count = shopify.DraftOrder.count()
        self.assertEqual(16, draft_orders_count)

    def test_create_draft_order(self):
        self.fake(
            "draft_orders",
            method="POST",
            code=201,
            body=self.load_fixture("draft_order"),
            headers={"Content-type": "application/json"},
        )
        draft_order = shopify.DraftOrder.create({"line_items": [{"quantity": 1, "variant_id": 39072856}]})
        self.assertEqual(
            json.loads('{"draft_order": {"line_items": [{"quantity": 1, "variant_id": 39072856}]}}'),
            json.loads(self.http.request.data.decode("utf-8")),
        )

    def test_create_draft_order_202(self):
        self.fake(
            "draft_orders",
            method="POST",
            code=202,
            body=self.load_fixture("draft_order"),
            headers={"Content-type": "application/json"},
        )
        draft_order = shopify.DraftOrder.create({"line_items": [{"quantity": 1, "variant_id": 39072856}]})
        self.assertEqual(39072856, draft_order.line_items[0].variant_id)

    def test_update_draft_order(self):
        self.draft_order.note = "Test new note"
        self.fake(
            "draft_orders/517119332",
            method="PUT",
            code=200,
            body=self.load_fixture("draft_order"),
            headers={"Content-type": "application/json"},
        )
        self.draft_order.save()
        self.assertEqual("Test new note", json.loads(self.http.request.data.decode("utf-8"))["draft_order"]["note"])

    def test_send_invoice_with_no_params(self):
        draft_order_invoice_fixture = self.load_fixture("draft_order_invoice")
        draft_order_invoice = json.loads(draft_order_invoice_fixture.decode("utf-8"))
        self.fake(
            "draft_orders/517119332/send_invoice",
            method="POST",
            body=draft_order_invoice_fixture,
            headers={"Content-type": "application/json"},
        )
        draft_order_invoice_response = self.draft_order.send_invoice()
        self.assertEqual(json.loads('{"draft_order_invoice": {}}'), json.loads(self.http.request.data.decode("utf-8")))
        self.assertIsInstance(draft_order_invoice_response, shopify.DraftOrderInvoice)
        self.assertEqual(draft_order_invoice["draft_order_invoice"]["to"], draft_order_invoice_response.to)

    def test_send_invoice_with_params(self):
        draft_order_invoice_fixture = self.load_fixture("draft_order_invoice")
        draft_order_invoice = json.loads(draft_order_invoice_fixture.decode("utf-8"))
        self.fake(
            "draft_orders/517119332/send_invoice",
            method="POST",
            body=draft_order_invoice_fixture,
            headers={"Content-type": "application/json"},
        )
        draft_order_invoice_response = self.draft_order.send_invoice(
            shopify.DraftOrderInvoice(draft_order_invoice["draft_order_invoice"])
        )
        self.assertEqual(draft_order_invoice, json.loads(self.http.request.data.decode("utf-8")))
        self.assertIsInstance(draft_order_invoice_response, shopify.DraftOrderInvoice)
        self.assertEqual(draft_order_invoice["draft_order_invoice"]["to"], draft_order_invoice_response.to)

    def test_delete_draft_order(self):
        self.fake("draft_orders/517119332", method="DELETE", body="destroyed")
        self.draft_order.destroy()
        self.assertEqual("DELETE", self.http.request.get_method())

    def test_add_metafields_to_draft_order(self):
        self.fake(
            "draft_orders/517119332/metafields",
            method="POST",
            code=201,
            body=self.load_fixture("metafield"),
            headers={"Content-type": "application/json"},
        )
        field = self.draft_order.add_metafield(
            shopify.Metafield(
                {"namespace": "contact", "key": "email", "value": "123@example.com", "value_type": "string"}
            )
        )
        self.assertEqual(
            json.loads(
                '{"metafield":{"namespace":"contact","key":"email","value":"123@example.com","value_type":"string"}}'
            ),
            json.loads(self.http.request.data.decode("utf-8")),
        )
        self.assertFalse(field.is_new())
        self.assertEqual("contact", field.namespace)
        self.assertEqual("email", field.key)
        self.assertEqual("123@example.com", field.value)

    def test_get_metafields_for_draft_order(self):
        self.fake("draft_orders/517119332/metafields", body=self.load_fixture("metafields"))
        metafields = self.draft_order.metafields()
        self.assertEqual(2, len(metafields))
        self.assertIsInstance(metafields[0], shopify.Metafield)
        self.assertIsInstance(metafields[1], shopify.Metafield)

    def test_complete_draft_order_with_no_params(self):
        completed_fixture = self.load_fixture("draft_order_completed")
        completed_draft = json.loads(completed_fixture.decode("utf-8"))["draft_order"]
        headers = {"Content-type": "application/json", "Content-length": "0"}
        self.fake("draft_orders/517119332/complete", method="PUT", body=completed_fixture, headers=headers)
        self.draft_order.complete()
        self.assertEqual(completed_draft["status"], self.draft_order.status)
        self.assertEqual(completed_draft["order_id"], self.draft_order.order_id)
        self.assertIsNotNone(self.draft_order.completed_at)

    def test_complete_draft_order_with_params(self):
        completed_fixture = self.load_fixture("draft_order_completed")
        completed_draft = json.loads(completed_fixture.decode("utf-8"))["draft_order"]
        headers = {"Content-type": "application/json", "Content-length": "0"}
        url = "draft_orders/517119332/complete.json?payment_pending=true"
        self.fake(url, extension=False, method="PUT", body=completed_fixture, headers=headers)
        self.draft_order.complete({"payment_pending": True})
        self.assertEqual(completed_draft["status"], self.draft_order.status)
        self.assertEqual(completed_draft["order_id"], self.draft_order.order_id)
        self.assertIsNotNone(self.draft_order.completed_at)


================================================
File: test/event_test.py
================================================
import shopify
from test.test_helper import TestCase


class EventTest(TestCase):
    def test_prefix_uses_resource(self):
        prefix = shopify.Event._prefix(options={"resource": "orders", "resource_id": 42})
        self.assertEqual("https://this-is-my-test-show.myshopify.com/admin/api/unstable/orders/42", prefix)

    def test_prefix_doesnt_need_resource(self):
        prefix = shopify.Event._prefix()
        self.assertEqual("https://this-is-my-test-show.myshopify.com/admin/api/unstable", prefix)


================================================
File: test/fulfillment_event_test.py
================================================
import shopify
from test.test_helper import TestCase


class FulFillmentEventTest(TestCase):
    def test_get_fulfillment_event(self):
        self.fake(
            "orders/2776493818019/fulfillments/2608403447971/events",
            method="GET",
            body=self.load_fixture("fulfillment_event"),
        )
        fulfillment_event = shopify.FulfillmentEvent.find(order_id=2776493818019, fulfillment_id=2608403447971)
        self.assertEqual(1, len(fulfillment_event))

    def test_create_fulfillment_event(self):
        self.fake(
            "orders/2776493818019/fulfillments/2608403447971/events",
            method="POST",
            body=self.load_fixture("fulfillment_event"),
            headers={"Content-type": "application/json"},
        )
        new_fulfillment_event = shopify.FulfillmentEvent(
            {"order_id": "2776493818019", "fulfillment_id": "2608403447971"}
        )
        new_fulfillment_event.status = "ready_for_pickup"
        new_fulfillment_event.save()

    def test_error_on_incorrect_status(self):
        with self.assertRaises(AttributeError):
            self.fake(
                "orders/2776493818019/fulfillments/2608403447971/events/12584341209251",
                method="GET",
                body=self.load_fixture("fulfillment_event"),
            )
            incorrect_status = "asdf"
            fulfillment_event = shopify.FulfillmentEvent.find(
                12584341209251, order_id="2776493818019", fulfillment_id="2608403447971"
            )
            fulfillment_event.status = incorrect_status
            fulfillment_event.save()


================================================
File: test/fulfillment_service_test.py
================================================
import shopify
from test.test_helper import TestCase


class FulfillmentServiceTest(TestCase):
    def test_create_new_fulfillment_service(self):
        self.fake(
            "fulfillment_services",
            method="POST",
            body=self.load_fixture("fulfillment_service"),
            headers={"Content-type": "application/json"},
        )

        fulfillment_service = shopify.FulfillmentService.create({"name": "SomeService"})
        self.assertEqual("SomeService", fulfillment_service.name)

    def test_get_fulfillment_service(self):
        self.fake("fulfillment_services/123456", method="GET", body=self.load_fixture("fulfillment_service"))

        fulfillment_service = shopify.FulfillmentService.find(123456)
        self.assertEqual("SomeService", fulfillment_service.name)

    def test_set_format_attribute(self):
        fulfillment_service = shopify.FulfillmentService()
        fulfillment_service.format = "json"
        self.assertEqual("json", fulfillment_service.attributes["format"])


================================================
File: test/fulfillment_test.py
================================================
import shopify
from test.test_helper import TestCase
from pyactiveresource.activeresource import ActiveResource


class FulFillmentTest(TestCase):
    def setUp(self):
        super(FulFillmentTest, self).setUp()
        self.fake("orders/450789469/fulfillments/255858046", method="GET", body=self.load_fixture("fulfillment"))

    def test_able_to_open_fulfillment(self):
        fulfillment = shopify.Fulfillment.find(255858046, order_id=450789469)

        success = self.load_fixture("fulfillment")
        success = success.replace(b"pending", b"open")
        self.fake(
            "orders/450789469/fulfillments/255858046/open",
            method="POST",
            headers={"Content-length": "0", "Content-type": "application/json"},
            body=success,
        )

        self.assertEqual("pending", fulfillment.status)
        fulfillment.open()
        self.assertEqual("open", fulfillment.status)

    def test_able_to_complete_fulfillment(self):
        fulfillment = shopify.Fulfillment.find(255858046, order_id=450789469)

        success = self.load_fixture("fulfillment")
        success = success.replace(b"pending", b"success")
        self.fake(
            "orders/450789469/fulfillments/255858046/complete",
            method="POST",
            headers={"Content-length": "0", "Content-type": "application/json"},
            body=success,
        )

        self.assertEqual("pending", fulfillment.status)
        fulfillment.complete()
        self.assertEqual("success", fulfillment.status)

    def test_able_to_cancel_fulfillment(self):
        fulfillment = shopify.Fulfillment.find(255858046, order_id=450789469)

        cancelled = self.load_fixture("fulfillment")
        cancelled = cancelled.replace(b"pending", b"cancelled")
        self.fake(
            "orders/450789469/fulfillments/255858046/cancel",
            method="POST",
            headers={"Content-length": "0", "Content-type": "application/json"},
            body=cancelled,
        )

        self.assertEqual("pending", fulfillment.status)
        fulfillment.cancel()
        self.assertEqual("cancelled", fulfillment.status)

    def test_update_tracking(self):
        fulfillment = shopify.Fulfillment.find(255858046, order_id=450789469)

        tracking_info = {"number": 1111, "url": "http://www.my-url.com", "company": "my-company"}
        notify_customer = False

        update_tracking = self.load_fixture("fulfillment")
        update_tracking = update_tracking.replace(b"null-company", b"my-company")
        update_tracking = update_tracking.replace(b"http://www.google.com/search?q=1Z2345", b"http://www.my-url.com")
        update_tracking = update_tracking.replace(b"1Z2345", b"1111")

        self.fake(
            "fulfillments/255858046/update_tracking",
            method="POST",
            headers={"Content-type": "application/json"},
            body=update_tracking,
        )

        self.assertEqual("null-company", fulfillment.tracking_company)
        self.assertEqual("1Z2345", fulfillment.tracking_number)
        self.assertEqual("http://www.google.com/search?q=1Z2345", fulfillment.tracking_url)
        fulfillment.update_tracking(tracking_info, notify_customer)
        self.assertEqual("my-company", fulfillment.tracking_company)
        self.assertEqual("1111", fulfillment.tracking_number)
        self.assertEqual("http://www.my-url.com", fulfillment.tracking_url)


================================================
File: test/gift_card_test.py
================================================
from decimal import Decimal
import shopify
from test.test_helper import TestCase


class GiftCardTest(TestCase):
    def test_gift_card_creation(self):
        self.fake(
            "gift_cards",
            method="POST",
            code=202,
            body=self.load_fixture("gift_card"),
            headers={"Content-type": "application/json"},
        )
        gift_card = shopify.GiftCard.create({"code": "d7a2bcggda89c293", "note": "Gift card note."})
        self.assertEqual("Gift card note.", gift_card.note)
        self.assertEqual("c293", gift_card.last_characters)

    def test_fetch_gift_cards(self):
        self.fake("gift_cards", method="GET", code=200, body=self.load_fixture("gift_cards"))
        gift_cards = shopify.GiftCard.find()
        self.assertEqual(1, len(gift_cards))

    def test_disable_gift_card(self):
        self.fake("gift_cards/4208208", method="GET", code=200, body=self.load_fixture("gift_card"))
        self.fake(
            "gift_cards/4208208/disable",
            method="POST",
            code=200,
            body=self.load_fixture("gift_card_disabled"),
            headers={"Content-length": "0", "Content-type": "application/json"},
        )
        gift_card = shopify.GiftCard.find(4208208)
        self.assertFalse(gift_card.disabled_at)
        gift_card.disable()
        self.assertTrue(gift_card.disabled_at)

    def test_adjust_gift_card(self):
        self.fake("gift_cards/4208208", method="GET", code=200, body=self.load_fixture("gift_card"))
        self.fake(
            "gift_cards/4208208/adjustments",
            method="POST",
            code=201,
            body=self.load_fixture("gift_card_adjustment"),
            headers={"Content-type": "application/json"},
        )
        gift_card = shopify.GiftCard.find(4208208)
        self.assertEqual(gift_card.balance, "25.00")
        adjustment = gift_card.add_adjustment(
            shopify.GiftCardAdjustment(
                {
                    "amount": 100,
                }
            )
        )
        self.assertIsInstance(adjustment, shopify.GiftCardAdjustment)
        self.assertEqual(Decimal(adjustment.amount), Decimal("100"))

    def test_search(self):
        self.fake(
            "gift_cards/search.json?query=balance%3A10", extension=False, body=self.load_fixture("gift_cards_search")
        )

        results = shopify.GiftCard.search(query="balance:10")
        self.assertEqual(results[0].balance, "10.00")


================================================
File: test/graphql_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class GraphQLTest(TestCase):
    def setUp(self):
        super(GraphQLTest, self).setUp()
        shopify.ApiVersion.define_known_versions()
        shopify_session = shopify.Session("this-is-my-test-show.myshopify.com", "unstable", "token")
        shopify.ShopifyResource.activate_session(shopify_session)
        self.client = shopify.GraphQL()
        self.fake(
            "graphql",
            method="POST",
            code=201,
            headers={
                "X-Shopify-Access-Token": "token",
                "Accept": "application/json",
                "Content-Type": "application/json",
            },
        )

    def test_fetch_shop_with_graphql(self):
        query = """
            {
                shop {
                    name
                    id
                }
            }
        """
        result = self.client.execute(query)
        self.assertTrue(json.loads(result)["shop"]["name"] == "Apple Computers")

    def test_specify_operation_name(self):
        query = """
            query GetShop{
                shop {
                    name
                    id
                }
            }
        """
        result = self.client.execute(query, operation_name="GetShop")
        self.assertTrue(json.loads(result)["shop"]["name"] == "Apple Computers")


================================================
File: test/image_test.py
================================================
import shopify
from test.test_helper import TestCase
import base64


class ImageTest(TestCase):
    def test_create_image(self):
        self.fake(
            "products/632910392/images",
            method="POST",
            body=self.load_fixture("image"),
            headers={"Content-type": "application/json"},
        )
        image = shopify.Image({"product_id": 632910392})
        image.position = 1
        image.attachment = "R0lGODlhbgCMAPf/APbr48VySrxTO7IgKt2qmKQdJeK8lsFjROG5p/nz7Zg3MNmnd7Q1MLNVS9GId71hSJMZIuzTu4UtKbeEeakhKMl8U8WYjfr18YQaIbAf=="
        image.save()

        self.assertEqual(
            "http://cdn.shopify.com/s/files/1/0006/9093/3842/products/ipod-nano.png?v=1389388540", image.src
        )
        self.assertEqual(850703190, image.id)

    def test_attach_image(self):
        self.fake(
            "products/632910392/images",
            method="POST",
            body=self.load_fixture("image"),
            headers={"Content-type": "application/json"},
        )
        image = shopify.Image({"product_id": 632910392})
        image.position = 1
        binary_in = base64.b64decode(
            "R0lGODlhbgCMAPf/APbr48VySrxTO7IgKt2qmKQdJeK8lsFjROG5p/nz7Zg3MNmnd7Q1MLNVS9GId71hSJMZIuzTu4UtKbeEeakhKMl8U8WYjfr18YQaIbAf=="
        )
        image.attach_image(data=binary_in, filename="ipod-nano.png")
        image.save()
        binary_out = base64.b64decode(image.attachment)

        self.assertEqual(
            "http://cdn.shopify.com/s/files/1/0006/9093/3842/products/ipod-nano.png?v=1389388540", image.src
        )
        self.assertEqual(850703190, image.id)
        self.assertEqual(binary_in, binary_out)

    def test_create_image_then_add_parent_id(self):
        self.fake(
            "products/632910392/images",
            method="POST",
            body=self.load_fixture("image"),
            headers={"Content-type": "application/json"},
        )
        image = shopify.Image()
        image.position = 1
        image.product_id = 632910392
        image.attachment = "R0lGODlhbgCMAPf/APbr48VySrxTO7IgKt2qmKQdJeK8lsFjROG5p/nz7Zg3MNmnd7Q1MLNVS9GId71hSJMZIuzTu4UtKbeEeakhKMl8U8WYjfr18YQaIbAf=="
        image.save()

        self.assertEqual(
            "http://cdn.shopify.com/s/files/1/0006/9093/3842/products/ipod-nano.png?v=1389388540", image.src
        )
        self.assertEqual(850703190, image.id)

    def test_get_images(self):
        self.fake("products/632910392/images", method="GET", body=self.load_fixture("images"))
        image = shopify.Image.find(product_id=632910392)
        self.assertEqual(2, len(image))

    def test_get_image(self):
        self.fake("products/632910392/images/850703190", method="GET", body=self.load_fixture("image"))
        image = shopify.Image.find(850703190, product_id=632910392)
        self.assertEqual(850703190, image.id)

    def test_get_metafields_for_image(self):
        fake_extension = "json?metafield[owner_id]=850703190&metafield[owner_resource]=product_image"
        self.fake("metafields", method="GET", extension=fake_extension, body=self.load_fixture("image_metafields"))

        image = shopify.Image(attributes={"id": 850703190, "product_id": 632910392})
        metafields = image.metafields()

        self.assertEqual(1, len(metafields))
        for field in metafields:
            self.assertTrue(isinstance(field, shopify.Metafield))
        self.assertEqual(metafields[0].value, "Image Alt Tag")


================================================
File: test/inventory_item_test.py
================================================
import shopify
from test.test_helper import TestCase


class InventoryItemTest(TestCase):
    def test_fetch_inventory_item(self):
        self.fake("inventory_items/123456789", method="GET", body=self.load_fixture("inventory_item"))
        inventory_item = shopify.InventoryItem.find(123456789)
        self.assertEqual(inventory_item.sku, "IPOD2008PINK")

    def test_fetch_inventory_item_ids(self):
        self.fake(
            "inventory_items.json?ids=123456789%2C234567891",
            extension="",
            method="GET",
            body=self.load_fixture("inventory_items"),
        )
        inventory_items = shopify.InventoryItem.find(ids="123456789,234567891")
        self.assertEqual(3, len(inventory_items))


================================================
File: test/inventory_level_test.py
================================================
import shopify
import json
from six.moves.urllib.parse import urlencode
from test.test_helper import TestCase


class InventoryLevelTest(TestCase):
    def test_fetch_inventory_level(self):
        params = {"inventory_item_ids": [808950810, 39072856], "location_ids": [905684977, 487838322]}

        self.fake(
            "inventory_levels.json?location_ids=905684977%2C487838322&inventory_item_ids=808950810%2C39072856",
            method="GET",
            extension="",
            body=self.load_fixture("inventory_levels"),
        )
        inventory_levels = shopify.InventoryLevel.find(
            inventory_item_ids="808950810,39072856", location_ids="905684977,487838322"
        )
        self.assertTrue(
            all(
                item.location_id in params["location_ids"] and item.inventory_item_id in params["inventory_item_ids"]
                for item in inventory_levels
            )
        )

    def test_inventory_level_adjust(self):
        self.fake(
            "inventory_levels/adjust",
            method="POST",
            body=self.load_fixture("inventory_level"),
            headers={"Content-type": "application/json"},
        )
        inventory_level = shopify.InventoryLevel.adjust(905684977, 808950810, 5)
        self.assertEqual(inventory_level.available, 6)

    def test_inventory_level_connect(self):
        self.fake(
            "inventory_levels/connect",
            method="POST",
            body=self.load_fixture("inventory_level"),
            headers={"Content-type": "application/json"},
            code=201,
        )
        inventory_level = shopify.InventoryLevel.connect(905684977, 808950810)
        self.assertEqual(inventory_level.available, 6)

    def test_inventory_level_set(self):
        self.fake(
            "inventory_levels/set",
            method="POST",
            body=self.load_fixture("inventory_level"),
            headers={"Content-type": "application/json"},
        )
        inventory_level = shopify.InventoryLevel.set(905684977, 808950810, 6)
        self.assertEqual(inventory_level.available, 6)

    def test_destroy_inventory_level(self):
        inventory_level_response = json.loads(self.load_fixture("inventory_level").decode())
        inventory_level = shopify.InventoryLevel(inventory_level_response["inventory_level"])

        query_params = urlencode(
            {"inventory_item_id": inventory_level.inventory_item_id, "location_id": inventory_level.location_id}
        )
        path = "inventory_levels.json?" + query_params

        self.fake(path, extension=False, method="DELETE", code=204, body="{}")
        inventory_level.destroy()


================================================
File: test/limits_test.py
================================================
import shopify
from mock import patch
from test.test_helper import TestCase


class LimitsTest(TestCase):
    """
    API Calls Limit Tests

    Conversion of test/limits_test.rb
    """

    @classmethod
    def setUpClass(self):
        self.original_headers = None

    def setUp(self):
        super(LimitsTest, self).setUp()
        self.fake("shop")
        shopify.Shop.current()
        # TODO: Fake not support Headers
        self.original_headers = shopify.Shop.connection.response.headers

    def tearDown(self):
        super(LimitsTest, self).tearDown()
        shopify.Shop.connection.response.headers = self.original_headers

    def test_raise_error_no_header(self):
        with self.assertRaises(Exception):
            shopify.Limits.credit_left()

    def test_raise_error_invalid_header(self):
        with patch.dict(shopify.Shop.connection.response.headers, {"bad": "value"}, clear=True):
            with self.assertRaises(Exception):
                shopify.Limits.credit_left()

    def test_fetch_limits_total(self):
        with patch.dict(
            shopify.Shop.connection.response.headers, {"X-Shopify-Shop-Api-Call-Limit": "40/40"}, clear=True
        ):
            self.assertEqual(40, shopify.Limits.credit_limit())

    def test_fetch_used_calls(self):
        with patch.dict(
            shopify.Shop.connection.response.headers, {"X-Shopify-Shop-Api-Call-Limit": "1/40"}, clear=True
        ):
            self.assertEqual(1, shopify.Limits.credit_used())

    def test_calculate_remaining_calls(self):
        with patch.dict(
            shopify.Shop.connection.response.headers, {"X-Shopify-Shop-Api-Call-Limit": "292/300"}, clear=True
        ):
            self.assertEqual(8, shopify.Limits.credit_left())

    def test_maxed_credits_false(self):
        with patch.dict(
            shopify.Shop.connection.response.headers, {"X-Shopify-Shop-Api-Call-Limit": "125/300"}, clear=True
        ):
            self.assertFalse(shopify.Limits.credit_maxed())

    def test_maxed_credits_true(self):
        with patch.dict(
            shopify.Shop.connection.response.headers, {"X-Shopify-Shop-Api-Call-Limit": "40/40"}, clear=True
        ):
            self.assertTrue(shopify.Limits.credit_maxed())


================================================
File: test/location_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class LocationTest(TestCase):
    def test_fetch_locations(self):
        self.fake("locations", method="GET", body=self.load_fixture("locations"))
        locations = shopify.Location.find()
        self.assertEqual(2, len(locations))

    def test_fetch_location(self):
        self.fake("locations/487838322", method="GET", body=self.load_fixture("location"))
        location = shopify.Location.find(487838322)
        self.assertEqual(location.id, 487838322)
        self.assertEqual(location.name, "Fifth Avenue AppleStore")

    def test_inventory_levels_returns_all_inventory_levels(self):
        location = shopify.Location({"id": 487838322})

        self.fake(
            "locations/%s/inventory_levels" % location.id,
            method="GET",
            code=200,
            body=self.load_fixture("location_inventory_levels"),
        )
        inventory_levels = location.inventory_levels()

        self.assertEqual(location.id, inventory_levels[0].location_id)
        self.assertEqual(27, inventory_levels[0].available)
        self.assertEqual(9, inventory_levels[1].available)


================================================
File: test/marketing_event_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class MarketingEventTest(TestCase):
    def test_get_marketing_event(self):
        self.fake("marketing_events/1", method="GET", body=self.load_fixture("marketing_event"))
        marketing_event = shopify.MarketingEvent.find(1)
        self.assertEqual(marketing_event.id, 1)

    def test_get_marketing_events(self):
        self.fake("marketing_events", method="GET", body=self.load_fixture("marketing_events"))
        marketing_events = shopify.MarketingEvent.find()
        self.assertEqual(len(marketing_events), 2)

    def test_create_marketing_event(self):
        self.fake(
            "marketing_events",
            method="POST",
            body=self.load_fixture("marketing_event"),
            headers={"Content-type": "application/json"},
        )

        marketing_event = shopify.MarketingEvent()
        marketing_event.currency_code = "GBP"
        marketing_event.event_target = "facebook"
        marketing_event.event_type = "post"
        marketing_event.save()

        self.assertEqual(marketing_event.event_target, "facebook")
        self.assertEqual(marketing_event.currency_code, "GBP")
        self.assertEqual(marketing_event.event_type, "post")

    def test_delete_marketing_event(self):
        self.fake("marketing_events/1", method="GET", body=self.load_fixture("marketing_event"))
        self.fake("marketing_events/1", method="DELETE", body="destroyed")

        marketing_event = shopify.MarketingEvent.find(1)
        marketing_event.destroy()

        self.assertEqual("DELETE", self.http.request.get_method())

    def test_update_marketing_event(self):
        self.fake("marketing_events/1", method="GET", code=200, body=self.load_fixture("marketing_event"))
        self.fake(
            "marketing_events/1",
            method="PUT",
            code=200,
            body=self.load_fixture("marketing_event"),
            headers={"Content-type": "application/json"},
        )

        marketing_event = shopify.MarketingEvent.find(1)
        marketing_event.currency = "USD"

        self.assertTrue(marketing_event.save())

    def test_count_marketing_events(self):
        self.fake("marketing_events/count", method="GET", body='{"count": 2}')
        marketing_events_count = shopify.MarketingEvent.count()
        self.assertEqual(marketing_events_count, 2)

    def test_add_engagements(self):
        self.fake("marketing_events/1", method="GET", body=self.load_fixture("marketing_event"))
        self.fake(
            "marketing_events/1/engagements",
            method="POST",
            code=201,
            body=self.load_fixture("engagement"),
            headers={"Content-type": "application/json"},
        )

        marketing_event = shopify.MarketingEvent.find(1)
        response = marketing_event.add_engagements(
            [
                {
                    "occurred_on": "2017-04-20",
                    "impressions_count": None,
                    "views_count": None,
                    "clicks_count": 10,
                    "shares_count": None,
                    "favorites_count": None,
                    "comments_count": None,
                    "ad_spend": None,
                    "is_cumulative": True,
                }
            ]
        )

        request_data = json.loads(self.http.request.data.decode("utf-8"))["engagements"]
        self.assertEqual(len(request_data), 1)
        self.assertEqual(request_data[0]["occurred_on"], "2017-04-20")

        response_data = json.loads(response.body.decode("utf-8"))["engagements"]
        self.assertEqual(len(response_data), 1)
        self.assertEqual(response_data[0]["occurred_on"], "2017-04-20")


================================================
File: test/order_risk_test.py
================================================
import shopify
from test.test_helper import TestCase


class OrderRiskTest(TestCase):
    def test_create_order_risk(self):
        self.fake(
            "orders/450789469/risks",
            method="POST",
            body=self.load_fixture("order_risk"),
            headers={"Content-type": "application/json"},
        )
        v = shopify.OrderRisk({"order_id": 450789469})
        v.message = "This order was placed from a proxy IP"
        v.recommendation = "cancel"
        v.score = "1.0"
        v.source = "External"
        v.merchant_message = "This order was placed from a proxy IP"
        v.display = True
        v.cause_cancel = True
        v.save()

        self.assertEqual(284138680, v.id)

    def test_get_order_risks(self):
        self.fake("orders/450789469/risks", method="GET", body=self.load_fixture("order_risks"))
        v = shopify.OrderRisk.find(order_id=450789469)
        self.assertEqual(2, len(v))

    def test_get_order_risk(self):
        self.fake("orders/450789469/risks/284138680", method="GET", body=self.load_fixture("order_risk"))
        v = shopify.OrderRisk.find(284138680, order_id=450789469)
        self.assertEqual(284138680, v.id)

    def test_delete_order_risk(self):
        self.fake("orders/450789469/risks/284138680", method="GET", body=self.load_fixture("order_risk"))
        self.fake("orders/450789469/risks/284138680", method="DELETE", body="destroyed")
        v = shopify.OrderRisk.find(284138680, order_id=450789469)
        v.destroy()

    def test_delete_order_risk(self):
        self.fake("orders/450789469/risks/284138680", method="GET", body=self.load_fixture("order_risk"))
        self.fake(
            "orders/450789469/risks/284138680",
            method="PUT",
            body=self.load_fixture("order_risk"),
            headers={"Content-type": "application/json"},
        )

        v = shopify.OrderRisk.find(284138680, order_id=450789469)
        v.position = 3
        v.save()


================================================
File: test/order_test.py
================================================
import shopify
from test.test_helper import TestCase
from pyactiveresource.activeresource import ActiveResource
from pyactiveresource.util import xml_to_dict


class OrderTest(TestCase):
    def test_should_be_loaded_correctly_from_order_xml(self):
        order_xml = """<?xml version="1.0" encoding="UTF-8"?>
          <order>
            <note-attributes type="array">
              <note-attribute>
                <name>size</name>
                <value>large</value>
              </note-attribute>
            </note-attributes>
          </order>"""
        order = shopify.Order(xml_to_dict(order_xml)["order"])

        self.assertEqual(1, len(order.note_attributes))

        note_attribute = order.note_attributes[0]
        self.assertEqual("size", note_attribute.name)
        self.assertEqual("large", note_attribute.value)

    def test_should_be_able_to_add_note_attributes_to_an_order(self):
        order = shopify.Order()
        order.note_attributes = []
        order.note_attributes.append(shopify.NoteAttribute({"name": "color", "value": "blue"}))

        order_xml = xml_to_dict(order.to_xml())
        note_attributes = order_xml["order"]["note_attributes"]
        self.assertTrue(isinstance(note_attributes, list))

        attribute = note_attributes[0]
        self.assertEqual("color", attribute["name"])
        self.assertEqual("blue", attribute["value"])

    def test_get_order(self):
        self.fake("orders/450789469", method="GET", body=self.load_fixture("order"))
        order = shopify.Order.find(450789469)
        self.assertEqual("bob.norman@hostmail.com", order.email)

    def test_get_order_transaction(self):
        self.fake("orders/450789469", method="GET", body=self.load_fixture("order"))
        order = shopify.Order.find(450789469)
        self.fake("orders/450789469/transactions", method="GET", body=self.load_fixture("transactions"))
        transactions = order.transactions()
        self.assertEqual("409.94", transactions[0].amount)

    def test_get_customer_orders(self):
        self.fake("customers/207119551/orders", method="GET", body=self.load_fixture("orders"), code=200)
        orders = shopify.Order.find(customer_id=207119551)
        self.assertIsInstance(orders[0], shopify.Order)
        self.assertEqual(450789469, orders[0].id)
        self.assertEqual(207119551, orders[0].customer.id)


================================================
File: test/pagination_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class PaginationTest(TestCase):
    def setUp(self):
        super(PaginationTest, self).setUp()
        prefix = self.http.site + "/admin/api/unstable"
        fixture = json.loads(self.load_fixture("products").decode())

        self.next_page_url = prefix + "/products.json?limit=2&page_info=FOOBAR"
        self.prev_page_url = prefix + "/products.json?limit=2&page_info=BAZQUUX"

        next_headers = {"Link": "<" + self.next_page_url + '>; rel="next"'}
        prev_headers = {"Link": "<" + self.prev_page_url + '>; rel="previous"'}

        self.fake(
            "products",
            url=prefix + "/products.json?limit=2",
            body=json.dumps({"products": fixture[:2]}),
            response_headers=next_headers,
        )
        self.fake(
            "products",
            url=prefix + "/products.json?limit=2&page_info=FOOBAR",
            body=json.dumps({"products": fixture[2:4]}),
            response_headers=prev_headers,
        )
        self.fake(
            "products",
            url=prefix + "/products.json?limit=2&page_info=BAZQUUX",
            body=json.dumps({"products": fixture[:2]}),
            response_headers=next_headers,
        )

    def test_nonpaginates_collection(self):
        self.fake("draft_orders", method="GET", code=200, body=self.load_fixture("draft_orders"))
        draft_orders = shopify.DraftOrder.find()
        self.assertEqual(1, len(draft_orders))
        self.assertEqual(517119332, draft_orders[0].id)
        self.assertIsInstance(
            draft_orders, shopify.collection.PaginatedCollection, "find() result is not PaginatedCollection"
        )

    def test_paginated_collection(self):
        items = shopify.Product.find(limit=2)
        self.assertIsInstance(items, shopify.collection.PaginatedCollection, "find() result is not PaginatedCollection")
        self.assertEqual(len(items), 2, "find() result has incorrect length")

    def test_pagination_next_page(self):
        c = shopify.Product.find(limit=2)
        self.assertEqual(c.next_page_url, self.next_page_url, "next url is incorrect")
        n = c.next_page()
        self.assertEqual(n.previous_page_url, self.prev_page_url, "prev url is incorrect")
        self.assertIsInstance(
            n, shopify.collection.PaginatedCollection, "next_page() result is not PaginatedCollection"
        )
        self.assertEqual(len(n), 2, "next_page() collection has incorrect length")
        self.assertIn("pagination", n.metadata)
        self.assertIn("previous", n.metadata["pagination"], "next_page() collection doesn't have a previous page")

        with self.assertRaises(IndexError, msg="next_page() did not raise with no next page"):
            n.next_page()

    def test_pagination_previous(self):
        c = shopify.Product.find(limit=2)
        self.assertEqual(c.next_page_url, self.next_page_url, "next url is incorrect")
        self.assertTrue(c.has_next_page())
        n = c.next_page()
        self.assertEqual(n.previous_page_url, self.prev_page_url, "prev url is incorrect")
        self.assertTrue(n.has_previous_page())

        p = n.previous_page()

        self.assertIsInstance(
            p, shopify.collection.PaginatedCollection, "previous_page() result is not PaginatedCollection"
        )
        self.assertEqual(len(p), 4, "previous_page() collection has incorrect length")  # cached
        self.assertIn("pagination", p.metadata)
        self.assertIn("next", p.metadata["pagination"], "previous_page() collection doesn't have a next page")

        with self.assertRaises(IndexError, msg="previous_page() did not raise with no previous page"):
            p.previous_page()

    def test_paginated_collection_iterator(self):
        c = shopify.Product.find(limit=2)

        i = iter(c)
        self.assertEqual(next(i).id, 1)
        self.assertEqual(next(i).id, 2)
        with self.assertRaises(StopIteration):
            next(i)

    def test_paginated_collection_no_cache(self):
        c = shopify.Product.find(limit=2)

        n = c.next_page(no_cache=True)
        self.assertIsNone(c._next, "no_cache=True still caches")
        self.assertIsNone(n._previous, "no_cache=True still caches")

        p = n.previous_page(no_cache=True)
        self.assertIsNone(p._next, "no_cache=True still caches")
        self.assertIsNone(n._previous, "no_cache=True still caches")

    def test_paginated_iterator(self):
        c = shopify.Product.find(limit=2)

        i = iter(shopify.PaginatedIterator(c))

        first_page = iter(next(i))
        self.assertEqual(next(first_page).id, 1)
        self.assertEqual(next(first_page).id, 2)
        with self.assertRaises(StopIteration):
            next(first_page)

        second_page = iter(next(i))
        self.assertEqual(next(second_page).id, 3)
        self.assertEqual(next(second_page).id, 4)
        with self.assertRaises(StopIteration):
            next(second_page)

        with self.assertRaises(StopIteration):
            next(i)


================================================
File: test/payouts_test.py
================================================
import shopify
from test.test_helper import TestCase


class PayoutsTest(TestCase):
    prefix = "/admin/api/unstable/shopify_payments"

    def test_get_payouts(self):
        self.fake("payouts", method="GET", prefix=self.prefix, body=self.load_fixture("payouts"))
        payouts = shopify.Payouts.find()
        self.assertGreater(len(payouts), 0)

    def test_get_one_payout(self):
        self.fake("payouts/623721858", method="GET", prefix=self.prefix, body=self.load_fixture("payout"))
        payouts = shopify.Payouts.find(623721858)
        self.assertEqual("paid", payouts.status)
        self.assertEqual("41.90", payouts.amount)


================================================
File: test/price_rules_test.py
================================================
import json
from test.test_helper import TestCase

import shopify


class PriceRuleTest(TestCase):
    def setUp(self):
        super(PriceRuleTest, self).setUp()
        self.fake("price_rules/1213131", body=self.load_fixture("price_rule"))
        self.price_rule = shopify.PriceRule.find(1213131)

    def test_get_price_rule(self):
        self.fake("price_rule/1213131", method="GET", code=200, body=self.load_fixture("price_rule"))
        price_rule = shopify.PriceRule.find(1213131)
        self.assertEqual(1213131, price_rule.id)

    def test_get_all_price_rules(self):
        self.fake("price_rules", method="GET", code=200, body=self.load_fixture("price_rules"))
        price_rules = shopify.PriceRule.find()
        self.assertEqual(2, len(price_rules))

    def test_update_price_rule(self):
        self.price_rule.title = "Buy One Get One"
        self.fake(
            "price_rules/1213131",
            method="PUT",
            code=200,
            body=self.load_fixture("price_rule"),
            headers={"Content-type": "application/json"},
        )
        self.price_rule.save()
        self.assertEqual("Buy One Get One", json.loads(self.http.request.data.decode("utf-8"))["price_rule"]["title"])

    def test_delete_price_rule(self):
        self.fake("price_rules/1213131", method="DELETE", body="destroyed")
        self.price_rule.destroy()
        self.assertEqual("DELETE", self.http.request.get_method())

    def test_price_rule_creation(self):
        self.fake(
            "price_rules",
            method="POST",
            code=202,
            body=self.load_fixture("price_rule"),
            headers={"Content-type": "application/json"},
        )
        price_rule = shopify.PriceRule.create(
            {
                "title": "BOGO",
                "target_type": "line_item",
                "target_selection": "all",
                "allocation_method": "across",
                "value_type": "percentage",
                "value": -100,
                "once_per_customer": "true",
                "customer_selection": "all",
            }
        )
        self.assertEqual("BOGO", price_rule.title)
        self.assertEqual("line_item", price_rule.target_type)

    def test_get_discount_codes(self):
        self.fake(
            "price_rules/1213131/discount_codes", method="GET", code=200, body=self.load_fixture("discount_codes")
        )
        discount_codes = self.price_rule.discount_codes()
        self.assertEqual(1, len(discount_codes))

    def test_add_discount_code(self):
        price_rule_discount_fixture = self.load_fixture("discount_code")
        discount_code = json.loads(price_rule_discount_fixture.decode("utf-8"))
        self.fake(
            "price_rules/1213131/discount_codes",
            method="POST",
            body=price_rule_discount_fixture,
            headers={"Content-type": "application/json"},
        )
        price_rule_discount_response = self.price_rule.add_discount_code(
            shopify.DiscountCode(discount_code["discount_code"])
        )
        self.assertEqual(discount_code, json.loads(self.http.request.data.decode("utf-8")))
        self.assertIsInstance(price_rule_discount_response, shopify.DiscountCode)
        self.assertEqual(discount_code["discount_code"]["code"], price_rule_discount_response.code)

    def test_create_batch_discount_codes(self):
        self.fake(
            "price_rules/1213131/batch",
            method="POST",
            code=201,
            body=self.load_fixture("discount_code_creation"),
            headers={"Content-type": "application/json"},
        )
        batch = self.price_rule.create_batch([{"code": "SUMMER1"}, {"code": "SUMMER2"}, {"code": "SUMMER3"}])

        self.assertEqual(3, batch.codes_count)
        self.assertEqual("queued", batch.status)

    def test_find_batch_job(self):
        self.fake(
            "price_rules/1213131/batch/989355119",
            method="GET",
            code=200,
            body=self.load_fixture("discount_code_creation"),
        )
        batch = self.price_rule.find_batch(989355119)

        self.assertEqual(3, batch.codes_count)
        self.assertEqual("queued", batch.status)


================================================
File: test/product_listing_test.py
================================================
import shopify
from test.test_helper import TestCase


class ProductListingTest(TestCase):
    def test_get_product_listings(self):
        self.fake("product_listings", method="GET", code=200, body=self.load_fixture("product_listings"))

        product_listings = shopify.ProductListing.find()
        self.assertEqual(2, len(product_listings))
        self.assertEqual(2, product_listings[0].product_id)
        self.assertEqual(1, product_listings[1].product_id)
        self.assertEqual("Synergistic Silk Chair", product_listings[0].title)
        self.assertEqual("Rustic Copper Bottle", product_listings[1].title)

    def test_get_product_listing(self):
        self.fake("product_listings/2", method="GET", code=200, body=self.load_fixture("product_listing"))

        product_listing = shopify.ProductListing.find(2)
        self.assertEqual("Synergistic Silk Chair", product_listing.title)

    def test_reload_product_listing(self):
        self.fake("product_listings/2", method="GET", code=200, body=self.load_fixture("product_listing"))

        product_listing = shopify.ProductListing()
        product_listing.product_id = 2
        product_listing.reload()

        self.assertEqual("Synergistic Silk Chair", product_listing.title)

    def test_get_product_listing_product_ids(self):
        self.fake(
            "product_listings/product_ids",
            method="GET",
            status=200,
            body=self.load_fixture("product_listing_product_ids"),
        )

        product_ids = shopify.ProductListing.product_ids()

        self.assertEqual(2, len(product_ids))
        self.assertEqual(2, product_ids[0])
        self.assertEqual(1, product_ids[1])


================================================
File: test/product_publication_test.py
================================================
import shopify
import json
from test.test_helper import TestCase


class ProductPublicationTest(TestCase):
    def test_find_all_product_publications(self):
        self.fake(
            "publications/55650051/product_publications", method="GET", body=self.load_fixture("product_publications")
        )
        product_publications = shopify.ProductPublication.find(publication_id=55650051)

        self.assertEqual(647162527768, product_publications[0].id)
        self.assertEqual(8267093571, product_publications[0].product_id)

    def test_find_product_publication(self):
        self.fake(
            "publications/55650051/product_publications/647162527768",
            method="GET",
            body=self.load_fixture("product_publication"),
            code=200,
        )
        product_publication = shopify.ProductPublication.find(647162527768, publication_id=55650051)

        self.assertEqual(647162527768, product_publication.id)
        self.assertEqual(8267093571, product_publication.product_id)

    def test_create_product_publication(self):
        self.fake(
            "publications/55650051/product_publications",
            method="POST",
            headers={"Content-type": "application/json"},
            body=self.load_fixture("product_publication"),
            code=201,
        )

        product_publication = shopify.ProductPublication.create(
            {
                "publication_id": 55650051,
                "published_at": "2018-01-29T14:06:08-05:00",
                "published": True,
                "product_id": 8267093571,
            }
        )

        expected_body = {
            "product_publication": {
                "published_at": "2018-01-29T14:06:08-05:00",
                "published": True,
                "product_id": 8267093571,
            }
        }

        self.assertEqual(expected_body, json.loads(self.http.request.data.decode("utf-8")))

    def test_destroy_product_publication(self):
        self.fake(
            "publications/55650051/product_publications/647162527768",
            method="GET",
            body=self.load_fixture("product_publication"),
            code=200,
        )
        product_publication = shopify.ProductPublication.find(647162527768, publication_id=55650051)

        self.fake("publications/55650051/product_publications/647162527768", method="DELETE", body="{}", code=200)
        product_publication.destroy()

        self.assertEqual("DELETE", self.http.request.get_method())


================================================
File: test/product_test.py
================================================
import shopify
from test.test_helper import TestCase


class ProductTest(TestCase):
    def setUp(self):
        super(ProductTest, self).setUp()

        self.fake("products/632910392", body=self.load_fixture("product"))
        self.product = shopify.Product.find(632910392)

    def test_add_metafields_to_product(self):
        self.fake(
            "products/632910392/metafields",
            method="POST",
            code=201,
            body=self.load_fixture("metafield"),
            headers={"Content-type": "application/json"},
        )

        field = self.product.add_metafield(
            shopify.Metafield(
                {"namespace": "contact", "key": "email", "value": "123@example.com", "value_type": "string"}
            )
        )

        self.assertFalse(field.is_new())
        self.assertEqual("contact", field.namespace)
        self.assertEqual("email", field.key)
        self.assertEqual("123@example.com", field.value)

    def test_get_metafields_for_product(self):
        self.fake("products/632910392/metafields", body=self.load_fixture("metafields"))

        metafields = self.product.metafields()

        self.assertEqual(2, len(metafields))
        for field in metafields:
            self.assertTrue(isinstance(field, shopify.Metafield))

    def test_get_metafields_for_product_with_params(self):
        self.fake("products/632910392/metafields.json?limit=2", extension=False, body=self.load_fixture("metafields"))

        metafields = self.product.metafields(limit=2)
        self.assertEqual(2, len(metafields))
        for field in metafields:
            self.assertTrue(isinstance(field, shopify.Metafield))

    def test_get_metafields_for_product_count(self):
        self.fake("products/632910392/metafields/count", body=self.load_fixture("metafields_count"))

        metafields_count = self.product.metafields_count()
        self.assertEqual(2, metafields_count)

    def test_get_metafields_for_product_count_with_params(self):
        self.fake(
            "products/632910392/metafields/count.json?value_type=string",
            extension=False,
            body=self.load_fixture("metafields_count"),
        )

        metafields_count = self.product.metafields_count(value_type="string")
        self.assertEqual(2, metafields_count)

    def test_update_loaded_variant(self):
        self.fake("products/632910392/variants/808950810", method="PUT", code=200, body=self.load_fixture("variant"))

        variant = self.product.variants[0]
        variant.price = "0.50"
        variant.save

    def test_add_variant_to_product(self):
        self.fake(
            "products/632910392/variants",
            method="POST",
            body=self.load_fixture("variant"),
            headers={"Content-type": "application/json"},
        )
        self.fake(
            "products/632910392/variants/808950810",
            method="PUT",
            code=200,
            body=self.load_fixture("variant"),
            headers={"Content-type": "application/json"},
        )
        v = shopify.Variant()
        self.assertTrue(self.product.add_variant(v))


================================================
File: test/publication_test.py
================================================
import shopify
from test.test_helper import TestCase


class PublicationTest(TestCase):
    def test_find_all_publications(self):
        self.fake("publications")
        publications = shopify.Publication.find()

        self.assertEqual(55650051, publications[0].id)
        self.assertEqual("Buy Button", publications[0].name)


================================================
File: test/recurring_charge_test.py
================================================
import shopify
from test.test_helper import TestCase


class RecurringApplicationChargeTest(TestCase):
    def test_activate_charge(self):
        # Just check that calling activate doesn't raise an exception.
        self.fake(
            "recurring_application_charges/35463/activate",
            method="POST",
            headers={"Content-length": "0", "Content-type": "application/json"},
            body=" ",
        )
        charge = shopify.RecurringApplicationCharge({"id": 35463})
        charge.activate()

    def test_current_method_returns_active_charge(self):
        # Test that current() class method correctly returns
        # first RecurringApplicationCharge with active status
        self.fake("recurring_application_charges")
        charge = shopify.RecurringApplicationCharge.current()
        self.assertEqual(charge.id, 455696195)

    def test_current_method_returns_none_if_active_not_found(self):
        # Test that current() class method correctly returns
        # None if RecurringApplicationCharge with active status not found
        self.fake("recurring_application_charges", body=self.load_fixture("recurring_application_charges_no_active"))
        charge = shopify.RecurringApplicationCharge.current()
        self.assertEqual(charge, None)

    def test_usage_charges_method_returns_associated_usage_charges(self):
        self.fake("recurring_application_charges")
        charge = shopify.RecurringApplicationCharge.current()

        self.fake(
            "recurring_application_charges/455696195/usage_charges",
            method="GET",
            body=self.load_fixture("usage_charges"),
        )
        usage_charges = charge.usage_charges()
        self.assertEqual(len(usage_charges), 2)

    def test_customize_method_increases_capped_amount(self):
        self.fake("recurring_application_charges")
        charge = shopify.RecurringApplicationCharge.current()
        self.assertEqual(charge.capped_amount, 100)

        self.fake(
            "recurring_application_charges/455696195/customize.json?recurring_application_charge%5Bcapped_amount%5D=200",
            extension=False,
            method="PUT",
            headers={"Content-length": "0", "Content-type": "application/json"},
            body=self.load_fixture("recurring_application_charge_adjustment"),
        )
        charge.customize(capped_amount=200)
        self.assertTrue(charge.update_capped_amount_url)

    def test_destroy_recurring_application_charge(self):
        self.fake("recurring_application_charges")
        charge = shopify.RecurringApplicationCharge.current()

        self.fake("recurring_application_charges/455696195", method="DELETE", body="{}")
        charge.destroy()


================================================
File: test/refund_test.py
================================================
import shopify
from test.test_helper import TestCase


class RefundTest(TestCase):
    def setUp(self):
        super(RefundTest, self).setUp()
        self.fake("orders/450789469/refunds/509562969", method="GET", body=self.load_fixture("refund"))

    def test_should_find_a_specific_refund(self):
        refund = shopify.Refund.find(509562969, order_id=450789469)
        self.assertEqual("209.00", refund.transactions[0].amount)

    def test_calculate_refund_for_order(self):
        self.fake(
            "orders/450789469/refunds/calculate",
            method="POST",
            code=201,
            body=self.load_fixture("refund_calculate"),
            headers={"Content-type": "application/json"},
        )
        refund = shopify.Refund.calculate(
            order_id=450789469, refund_line_items=[{"line_item_id": 518995019, "quantity": 1}]
        )

        self.assertEqual("suggested_refund", refund.transactions[0].kind)
        self.assertEqual("41.94", refund.transactions[0].amount)
        self.assertEqual(518995019, refund.refund_line_items[0].line_item_id)


================================================
File: test/report_test.py
================================================
import shopify
from test.test_helper import TestCase


class CustomerSavedSearchTest(TestCase):
    def test_get_report(self):
        self.fake("reports/987", method="GET", code=200, body=self.load_fixture("report"))
        report = shopify.Report.find(987)
        self.assertEqual(987, report.id)

    def test_get_reports(self):
        self.fake("reports", method="GET", code=200, body=self.load_fixture("reports"))
        reports = shopify.Report.find()
        self.assertEqual("custom_app_reports", reports[0].category)

    def test_create_report(self):
        self.fake(
            "reports",
            method="POST",
            code=201,
            body=self.load_fixture("report"),
            headers={"Content-type": "application/json"},
        )
        report = shopify.Report.create(
            {
                "name": "Custom App Report",
                "shopify_ql": "SHOW quantity_count, total_sales BY product_type, vendor, product_title FROM products SINCE -1m UNTIL -0m ORDER BY total_sales DESC",
            }
        )
        self.assertEqual("custom_app_reports", report.category)

    def test_delete_report(self):
        self.fake("reports/987", method="GET", code=200, body=self.load_fixture("report"))
        self.fake("reports", method="DELETE", code=200, body="[]")
        report = shopify.Report.find(987)
        self.assertTrue(report.destroy)


================================================
File: test/resource_feedback_test.py
================================================
import json
import shopify
from test.test_helper import TestCase


class ResourceFeedbackTest(TestCase):
    def test_get_resource_feedback(self):
        body = json.dumps({"resource_feedback": [{"resource_type": "Shop"}]})
        self.fake("resource_feedback", method="GET", body=body)

        feedback = shopify.ResourceFeedback.find()

        self.assertEqual("Shop", feedback[0].resource_type)

    def test_save_with_resource_feedback_endpoint(self):
        body = json.dumps({"resource_feedback": {}})
        self.fake("resource_feedback", method="POST", body=body, headers={"Content-Type": "application/json"})

        shopify.ResourceFeedback().save()

        self.assertEqual(body, self.http.request.data.decode("utf-8"))

    def test_get_resource_feedback_with_product_id(self):
        body = json.dumps({"resource_feedback": [{"resource_type": "Product"}]})
        self.fake("products/42/resource_feedback", method="GET", body=body)

        feedback = shopify.ResourceFeedback.find(product_id=42)

        self.assertEqual("Product", feedback[0].resource_type)

    def test_save_with_product_id_resource_feedback_endpoint(self):
        body = json.dumps({"resource_feedback": {}})
        self.fake(
            "products/42/resource_feedback", method="POST", body=body, headers={"Content-Type": "application/json"}
        )

        feedback = shopify.ResourceFeedback({"product_id": 42})
        feedback.save()

        self.assertEqual(body, self.http.request.data.decode("utf-8"))


================================================
File: test/session_test.py
================================================
import shopify
from test.test_helper import TestCase
import hmac
from hashlib import sha256
import time
from six.moves import urllib
from six import u


class SessionTest(TestCase):
    @classmethod
    def setUpClass(self):
        shopify.ApiVersion.define_known_versions()
        shopify.ApiVersion.define_version(shopify.Release("2019-04"))

    @classmethod
    def tearDownClass(self):
        shopify.ApiVersion.clear_defined_versions()

    def test_not_be_valid_without_a_url(self):
        session = shopify.Session("", "unstable", "any-token")
        self.assertFalse(session.valid)

    def test_not_be_valid_without_token(self):
        session = shopify.Session("testshop.myshopify.com", "unstable")
        self.assertFalse(session.valid)

    def test_be_valid_with_any_token_and_any_url(self):
        session = shopify.Session("testshop.myshopify.com", "unstable", "any-token")
        self.assertTrue(session.valid)

    def test_ignore_everything_but_the_subdomain_in_the_shop(self):
        session = shopify.Session("http://user:pass@testshop.notshopify.net/path", "unstable", "any-token")
        self.assertEqual("https://testshop.myshopify.com/admin/api/unstable", session.site)

    def test_append_the_myshopify_domain_if_not_given(self):
        session = shopify.Session("testshop", "unstable", "any-token")
        self.assertEqual("https://testshop.myshopify.com/admin/api/unstable", session.site)

    def test_raise_error_if_params_passed_but_signature_omitted(self):
        with self.assertRaises(shopify.ValidationException):
            session = shopify.Session("testshop.myshopify.com", "unstable")
            token = session.request_token({"code": "any_code", "foo": "bar", "timestamp": "1234"})

    def test_setup_api_key_and_secret_for_all_sessions(self):
        shopify.Session.setup(api_key="My test key", secret="My test secret")
        self.assertEqual("My test key", shopify.Session.api_key)
        self.assertEqual("My test secret", shopify.Session.secret)

    def test_use_https_protocol_by_default_for_all_sessions(self):
        self.assertEqual("https", shopify.Session.protocol)

    def test_temp_reset_shopify_shopify_resource_site_to_original_value(self):
        shopify.Session.setup(api_key="key", secret="secret")
        session1 = shopify.Session("fakeshop.myshopify.com", "2019-04", "token1")
        shopify.ShopifyResource.activate_session(session1)

        assigned_site = ""
        with shopify.Session.temp("testshop.myshopify.com", "unstable", "any-token"):
            assigned_site = shopify.ShopifyResource.site

        self.assertEqual("https://testshop.myshopify.com/admin/api/unstable", assigned_site)
        self.assertEqual("https://fakeshop.myshopify.com/admin/api/2019-04", shopify.ShopifyResource.site)

    def test_myshopify_domain_supports_non_standard_ports(self):
        try:
            shopify.Session.setup(api_key="key", secret="secret", myshopify_domain="localhost", port=3000)

            session = shopify.Session("fakeshop.localhost:3000", "unstable", "token1")
            shopify.ShopifyResource.activate_session(session)
            self.assertEqual("https://fakeshop.localhost:3000/admin/api/unstable", shopify.ShopifyResource.site)

            session = shopify.Session("fakeshop", "unstable", "token1")
            shopify.ShopifyResource.activate_session(session)
            self.assertEqual("https://fakeshop.localhost:3000/admin/api/unstable", shopify.ShopifyResource.site)
        finally:
            shopify.Session.setup(myshopify_domain="myshopify.com", port=None)

    def test_temp_works_without_currently_active_session(self):
        shopify.ShopifyResource.clear_session()

        assigned_site = ""
        with shopify.Session.temp("testshop.myshopify.com", "unstable", "any-token"):
            assigned_site = shopify.ShopifyResource.site

        self.assertEqual("https://testshop.myshopify.com/admin/api/unstable", assigned_site)
        self.assertEqual("https://none/admin/api/unstable", shopify.ShopifyResource.site)

    def test_create_permission_url_returns_correct_url_with_redirect_uri(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        permission_url = session.create_permission_url("my_redirect_uri.com")
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_and_single_scope(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        scope = ["write_products"]
        permission_url = session.create_permission_url("my_redirect_uri.com", scope=scope)
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com&scope=write_products",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_and_dual_scope(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        scope = ["write_products", "write_customers"]
        permission_url = session.create_permission_url("my_redirect_uri.com", scope=scope)
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com&scope=write_products%2Cwrite_customers",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_and_empty_scope(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        scope = []
        permission_url = session.create_permission_url("my_redirect_uri.com", scope=scope)
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_and_state(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        permission_url = session.create_permission_url("my_redirect_uri.com", state="mystate")
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com&state=mystate",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_empty_scope_and_state(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        scope = []
        permission_url = session.create_permission_url("my_redirect_uri.com", scope=scope, state="mystate")
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com&state=mystate",
            self.normalize_url(permission_url),
        )

    def test_create_permission_url_returns_correct_url_with_redirect_uri_and_single_scope_and_state(self):
        shopify.Session.setup(api_key="My_test_key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        scope = ["write_customers"]
        permission_url = session.create_permission_url("my_redirect_uri.com", scope=scope, state="mystate")
        self.assertEqual(
            "https://localhost.myshopify.com/admin/oauth/authorize?client_id=My_test_key&redirect_uri=my_redirect_uri.com&scope=write_customers&state=mystate",
            self.normalize_url(permission_url),
        )

    def test_raise_exception_if_code_invalid_in_request_token(self):
        shopify.Session.setup(api_key="My test key", secret="My test secret")
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        self.fake(
            None,
            url="https://localhost.myshopify.com/admin/oauth/access_token",
            method="POST",
            code=404,
            body='{"error" : "invalid_request"}',
            has_user_agent=False,
        )

        with self.assertRaises(shopify.ValidationException):
            session.request_token({"code": "any-code", "timestamp": "1234"})

        self.assertFalse(session.valid)

    def test_return_site_for_session(self):
        session = shopify.Session("testshop.myshopify.com", "unstable", "any-token")
        self.assertEqual("https://testshop.myshopify.com/admin/api/unstable", session.site)

    def test_hmac_calculation(self):
        # Test using the secret and parameter examples given in the Shopify API documentation.
        shopify.Session.secret = "hush"
        params = {
            "shop": "some-shop.myshopify.com",
            "code": "a94a110d86d2452eb3e2af4cfb8a3828",
            "timestamp": "1337178173",
            "hmac": "2cb1a277650a659f1b11e92a4a64275b128e037f2c3390e3c8fd2d8721dac9e2",
        }
        self.assertEqual(shopify.Session.calculate_hmac(params), params["hmac"])

    def test_hmac_calculation_with_ampersand_and_equal_sign_characters(self):
        shopify.Session.secret = "secret"
        params = {"a": "1&b=2", "c=3&d": "4"}
        to_sign = "a=1%26b=2&c%3D3%26d=4"
        expected_hmac = hmac.new("secret".encode(), to_sign.encode(), sha256).hexdigest()
        self.assertEqual(shopify.Session.calculate_hmac(params), expected_hmac)

    def test_hmac_validation(self):
        # Test using the secret and parameter examples given in the Shopify API documentation.
        shopify.Session.secret = "hush"
        params = {
            "shop": "some-shop.myshopify.com",
            "code": "a94a110d86d2452eb3e2af4cfb8a3828",
            "timestamp": "1337178173",
            "hmac": u("2cb1a277650a659f1b11e92a4a64275b128e037f2c3390e3c8fd2d8721dac9e2"),
        }
        self.assertTrue(shopify.Session.validate_hmac(params))

    def test_parameter_validation_handles_missing_params(self):
        # Test using the secret and parameter examples given in the Shopify API documentation.
        shopify.Session.secret = "hush"
        params = {
            "shop": "some-shop.myshopify.com",
            "code": "a94a110d86d2452eb3e2af4cfb8a3828",
            "hmac": u("2cb1a277650a659f1b11e92a4a64275b128e037f2c3390e3c8fd2d8721dac9e2"),
        }
        self.assertFalse(shopify.Session.validate_params(params))

    def test_param_validation_of_param_values_with_lists(self):
        shopify.Session.secret = "hush"
        params = {
            "shop": "some-shop.myshopify.com",
            "ids[]": [
                2,
                1,
            ],
            "hmac": u("b93b9f82996f6f8bf9f1b7bbddec284c8fabacdc4e12dc80550b4705f3003b1e"),
        }
        self.assertEqual(True, shopify.Session.validate_hmac(params))

    def test_return_token_and_scope_if_hmac_is_valid(self):
        shopify.Session.secret = "secret"
        params = {"code": "any-code", "timestamp": time.time()}
        hmac = shopify.Session.calculate_hmac(params)
        params["hmac"] = hmac

        self.fake(
            None,
            url="https://localhost.myshopify.com/admin/oauth/access_token",
            method="POST",
            body='{"access_token" : "token", "scope": "read_products,write_orders"}',
            has_user_agent=False,
        )
        session = shopify.Session("http://localhost.myshopify.com", "unstable")
        token = session.request_token(params)
        self.assertEqual("token", token)
        self.assertEqual(shopify.ApiAccess("read_products,write_orders"), session.access_scopes)

    def test_raise_error_if_hmac_is_invalid(self):
        shopify.Session.secret = "secret"
        params = {"code": "any-code", "timestamp": time.time()}
        params["hmac"] = "a94a110d86d2452e92a4a64275b128e9273be3037f2c339eb3e2af4cfb8a3828"

        with self.assertRaises(shopify.ValidationException):
            session = shopify.Session("http://localhost.myshopify.com", "unstable")
            session = session.request_token(params)

    def test_raise_error_if_hmac_does_not_match_expected(self):
        shopify.Session.secret = "secret"
        params = {"foo": "hello", "timestamp": time.time()}
        hmac = shopify.Session.calculate_hmac(params)
        params["hmac"] = hmac
        params["bar"] = "world"
        params["code"] = "code"

        with self.assertRaises(shopify.ValidationException):
            session = shopify.Session("http://localhost.myshopify.com", "unstable")
            session = session.request_token(params)

    def test_raise_error_if_timestamp_is_too_old(self):
        shopify.Session.secret = "secret"
        one_day = 24 * 60 * 60
        params = {"code": "any-code", "timestamp": time.time() - (2 * one_day)}
        hmac = shopify.Session.calculate_hmac(params)
        params["hmac"] = hmac

        with self.assertRaises(shopify.ValidationException):
            session = shopify.Session("http://localhost.myshopify.com", "unstable")
            session = session.request_token(params)

    def test_access_scopes_are_nil_by_default(self):
        session = shopify.Session("testshop.myshopify.com", "unstable", "any-token")
        self.assertIsNone(session.access_scopes)

    def test_access_scopes_when_valid_scopes_passed_in(self):
        session = shopify.Session(
            shop_url="testshop.myshopify.com",
            version="unstable",
            token="any-token",
            access_scopes="read_products, write_orders",
        )

        expected_access_scopes = shopify.ApiAccess("read_products, write_orders")
        self.assertEqual(expected_access_scopes, session.access_scopes)

    def test_access_scopes_set_with_api_access_object_passed_in(self):
        session = shopify.Session(
            shop_url="testshop.myshopify.com",
            version="unstable",
            token="any-token",
            access_scopes=shopify.ApiAccess("read_products, write_orders"),
        )

        expected_access_scopes = shopify.ApiAccess("read_products, write_orders")
        self.assertEqual(expected_access_scopes, session.access_scopes)

    def normalize_url(self, url):
        scheme, netloc, path, query, fragment = urllib.parse.urlsplit(url)
        query = "&".join(sorted(query.split("&")))
        return urllib.parse.urlunsplit((scheme, netloc, path, query, fragment))

    def test_session_with_coerced_version(self):
        future_version = "2030-01"
        session = shopify.Session("test.myshopify.com", future_version, "token")
        self.assertEqual(session.api_version.name, future_version)
        self.assertEqual(
            session.api_version.api_path("https://test.myshopify.com"),
            f"https://test.myshopify.com/admin/api/{future_version}",
        )

    def test_session_with_invalid_version(self):
        with self.assertRaises(shopify.VersionNotFoundError):
            shopify.Session("test.myshopify.com", "invalid-version", "token")


================================================
File: test/session_token_test.py
================================================
from shopify import session_token
from test.test_helper import TestCase
from datetime import datetime, timedelta

import jwt
import sys

if sys.version_info[0] < 3:  # Backwards compatibility for python < v3.0.0
    import time


def timestamp(date):
    return time.mktime(date.timetuple()) if sys.version_info[0] < 3 else date.timestamp()


class TestSessionTokenGetDecodedSessionToken(TestCase):
    @classmethod
    def setUpClass(self):
        self.secret = "API Secret"
        self.api_key = "API key"

    @classmethod
    def setUp(self):
        current_time = datetime.now()
        self.payload = {
            "iss": "https://test-shop.myshopify.com/admin",
            "dest": "https://test-shop.myshopify.com",
            "aud": self.api_key,
            "sub": "1",
            "exp": timestamp((current_time + timedelta(0, 60))),
            "nbf": timestamp(current_time),
            "iat": timestamp(current_time),
            "jti": "4321",
            "sid": "abc123",
        }

    @classmethod
    def build_auth_header(self):
        mock_session_token = jwt.encode(self.payload, self.secret, algorithm="HS256")
        return "Bearer {session_token}".format(session_token=mock_session_token)

    def test_raises_if_token_authentication_header_is_not_bearer(self):
        authorization_header = "Bad auth header"

        with self.assertRaises(session_token.TokenAuthenticationError) as cm:
            session_token.decode_from_header(authorization_header, api_key=self.api_key, secret=self.secret)

        self.assertEqual("The HTTP_AUTHORIZATION_HEADER provided does not contain a Bearer token", str(cm.exception))

    def test_raises_jwt_error_if_session_token_is_expired(self):
        self.payload["exp"] = timestamp((datetime.now() + timedelta(0, -11)))

        with self.assertRaises(session_token.SessionTokenError) as cm:
            session_token.decode_from_header(self.build_auth_header(), api_key=self.api_key, secret=self.secret)

        self.assertEqual("Signature has expired", str(cm.exception))

    def test_raises_jwt_error_if_invalid_alg(self):
        bad_session_token = jwt.encode(self.payload, None, algorithm="none")
        invalid_header = "Bearer {session_token}".format(session_token=bad_session_token)

        with self.assertRaises(session_token.SessionTokenError) as cm:
            session_token.decode_from_header(invalid_header, api_key=self.api_key, secret=self.secret)

        self.assertEqual("The specified alg value is not allowed", str(cm.exception))

    def test_raises_jwt_error_if_invalid_signature(self):
        bad_session_token = jwt.encode(self.payload, "bad_secret", algorithm="HS256")
        invalid_header = "Bearer {session_token}".format(session_token=bad_session_token)

        with self.assertRaises(session_token.SessionTokenError) as cm:
            session_token.decode_from_header(invalid_header, api_key=self.api_key, secret=self.secret)

        self.assertEqual("Signature verification failed", str(cm.exception))

    def test_raises_if_aud_doesnt_match_api_key(self):
        self.payload["aud"] = "bad audience"

        with self.assertRaises(session_token.SessionTokenError) as cm:
            session_token.decode_from_header(self.build_auth_header(), api_key=self.api_key, secret=self.secret)

        self.assertEqual("Audience doesn't match", str(cm.exception))

    def test_raises_if_issuer_hostname_is_invalid(self):
        self.payload["iss"] = "bad_shop_hostname"

        with self.assertRaises(session_token.InvalidIssuerError) as cm:
            session_token.decode_from_header(self.build_auth_header(), api_key=self.api_key, secret=self.secret)

        self.assertEqual("Invalid issuer", str(cm.exception))

    def test_raises_if_iss_and_dest_dont_match(self):
        self.payload["dest"] = "bad_shop.myshopify.com"

        with self.assertRaises(session_token.MismatchedHostsError) as cm:
            session_token.decode_from_header(self.build_auth_header(), api_key=self.api_key, secret=self.secret)

        self.assertEqual("The issuer and destination do not match", str(cm.exception))

    def test_returns_decoded_payload(self):
        decoded_payload = session_token.decode_from_header(
            self.build_auth_header(), api_key=self.api_key, secret=self.secret
        )

        self.assertEqual(self.payload, decoded_payload)

    def test_allow_10_seconds_clock_skew_in_nbf(self):
        self.payload["nbf"] = timestamp((datetime.now() + timedelta(seconds=10)))

        session_token.decode_from_header(self.build_auth_header(), api_key=self.api_key, secret=self.secret)


================================================
File: test/shipping_zone_test.py
================================================
import shopify
from test.test_helper import TestCase


class ShippingZoneTest(TestCase):
    def test_get_shipping_zones(self):
        self.fake("shipping_zones", method="GET", body=self.load_fixture("shipping_zones"))
        shipping_zones = shopify.ShippingZone.find()
        self.assertEqual(1, len(shipping_zones))
        self.assertEqual(shipping_zones[0].name, "Some zone")
        self.assertEqual(3, len(shipping_zones[0].countries))


================================================
File: test/shop_test.py
================================================
import shopify
from test.test_helper import TestCase


class ShopTest(TestCase):
    def setUp(self):
        super(ShopTest, self).setUp()
        self.fake("shop")
        self.shop = shopify.Shop.current()

    def test_current_should_return_current_shop(self):
        self.assertTrue(isinstance(self.shop, shopify.Shop))
        self.assertEqual("Apple Computers", self.shop.name)
        self.assertEqual("apple.myshopify.com", self.shop.myshopify_domain)
        self.assertEqual(690933842, self.shop.id)
        self.assertEqual("2007-12-31T19:00:00-05:00", self.shop.created_at)
        self.assertIsNone(self.shop.tax_shipping)

    def test_get_metafields_for_shop(self):
        self.fake("metafields")

        metafields = self.shop.metafields()

        self.assertEqual(2, len(metafields))
        for field in metafields:
            self.assertTrue(isinstance(field, shopify.Metafield))

    def test_add_metafield(self):
        self.fake(
            "metafields",
            method="POST",
            code=201,
            body=self.load_fixture("metafield"),
            headers={"Content-type": "application/json"},
        )

        field = self.shop.add_metafield(
            shopify.Metafield(
                {"namespace": "contact", "key": "email", "value": "123@example.com", "value_type": "string"}
            )
        )

        self.assertFalse(field.is_new())
        self.assertEqual("contact", field.namespace)
        self.assertEqual("email", field.key)
        self.assertEqual("123@example.com", field.value)

    def test_events(self):
        self.fake("events")

        events = self.shop.events()

        self.assertEqual(3, len(events))
        for event in events:
            self.assertTrue(isinstance(event, shopify.Event))


================================================
File: test/storefront_access_token_test.py
================================================
import shopify
from test.test_helper import TestCase


class StorefrontAccessTokenTest(TestCase):
    def test_create_storefront_access_token(self):
        self.fake(
            "storefront_access_tokens",
            method="POST",
            body=self.load_fixture("storefront_access_token"),
            headers={"Content-type": "application/json"},
        )
        storefront_access_token = shopify.StorefrontAccessToken.create({"title": "Test"})
        self.assertEqual(1, storefront_access_token.id)
        self.assertEqual("Test", storefront_access_token.title)

    def test_get_and_delete_storefront_access_token(self):
        self.fake(
            "storefront_access_tokens/1", method="GET", code=200, body=self.load_fixture("storefront_access_token")
        )
        storefront_access_token = shopify.StorefrontAccessToken.find(1)

        self.fake("storefront_access_tokens/1", method="DELETE", code=200, body="destroyed")
        storefront_access_token.destroy()
        self.assertEqual("DELETE", self.http.request.get_method())

    def test_get_storefront_access_tokens(self):
        self.fake(
            "storefront_access_tokens", method="GET", code=200, body=self.load_fixture("storefront_access_tokens")
        )
        tokens = shopify.StorefrontAccessToken.find()

        self.assertEqual(2, len(tokens))
        self.assertEqual(1, tokens[0].id)
        self.assertEqual(2, tokens[1].id)
        self.assertEqual("Test 1", tokens[0].title)
        self.assertEqual("Test 2", tokens[1].title)


================================================
File: test/tender_transaction_test.py
================================================
import shopify
from test.test_helper import TestCase


class TenderTransactionTest(TestCase):
    def setUp(self):
        super(TenderTransactionTest, self).setUp()
        self.fake("tender_transactions", method="GET", body=self.load_fixture("tender_transactions"))

    def test_should_load_all_tender_transactions(self):
        tender_transactions = shopify.TenderTransaction.find()
        self.assertEqual(3, len(tender_transactions))
        self.assertEqual([1, 2, 3], list(map(lambda t: t.id, tender_transactions)))


================================================
File: test/test_helper.py
================================================
import os
import sys
import unittest
from pyactiveresource.activeresource import ActiveResource
from pyactiveresource.testing import http_fake
import shopify


class TestCase(unittest.TestCase):
    def setUp(self):
        ActiveResource.site = None
        ActiveResource.headers = None

        shopify.ShopifyResource.clear_session()
        shopify.ShopifyResource.site = "https://this-is-my-test-show.myshopify.com/admin/api/unstable"
        shopify.ShopifyResource.password = None
        shopify.ShopifyResource.user = None

        http_fake.initialize()
        self.http = http_fake.TestHandler
        self.http.set_response(Exception("Bad request"))
        self.http.site = "https://this-is-my-test-show.myshopify.com"

    def load_fixture(self, name, format="json"):
        with open(os.path.dirname(__file__) + "/fixtures/%s.%s" % (name, format), "rb") as f:
            return f.read()

    def fake(self, endpoint, **kwargs):
        body = kwargs.pop("body", None) or self.load_fixture(endpoint)
        format = kwargs.pop("format", "json")
        method = kwargs.pop("method", "GET")
        prefix = kwargs.pop("prefix", "/admin/api/unstable")

        if "extension" in kwargs and not kwargs["extension"]:
            extension = ""
        else:
            extension = ".%s" % (kwargs.pop("extension", "json"))

        url = "https://this-is-my-test-show.myshopify.com%s/%s%s" % (prefix, endpoint, extension)
        try:
            url = kwargs["url"]
        except KeyError:
            pass

        headers = {}
        if kwargs.pop("has_user_agent", True):
            userAgent = "ShopifyPythonAPI/%s Python/%s" % (shopify.VERSION, sys.version.split(" ", 1)[0])
            headers["User-agent"] = userAgent

        try:
            headers.update(kwargs["headers"])
        except KeyError:
            pass

        code = kwargs.pop("code", 200)

        self.http.respond_to(
            method, url, headers, body=body, code=code, response_headers=kwargs.pop("response_headers", None)
        )


================================================
File: test/transaction_test.py
================================================
import shopify
from test.test_helper import TestCase


class TransactionTest(TestCase):
    def setUp(self):
        super(TransactionTest, self).setUp()
        self.fake("orders/450789469/transactions/389404469", method="GET", body=self.load_fixture("transaction"))

    def test_should_find_a_specific_transaction(self):
        transaction = shopify.Transaction.find(389404469, order_id=450789469)
        self.assertEqual("409.94", transaction.amount)


================================================
File: test/transactions_test.py
================================================
import shopify
from test.test_helper import TestCase


class TransactionsTest(TestCase):
    prefix = "/admin/api/unstable/shopify_payments/balance"

    def test_get_payouts_transactions(self):
        self.fake("transactions", method="GET", prefix=self.prefix, body=self.load_fixture("payouts_transactions"))
        transactions = shopify.Transactions.find()
        self.assertGreater(len(transactions), 0)


================================================
File: test/usage_charge_test.py
================================================
import shopify
from test.test_helper import TestCase


class UsageChargeTest(TestCase):
    def test_create_usage_charge(self):
        self.fake(
            "recurring_application_charges/654381177/usage_charges",
            method="POST",
            body=self.load_fixture("usage_charge"),
            headers={"Content-type": "application/json"},
        )

        charge = shopify.UsageCharge(
            {"price": 9.0, "description": "1000 emails", "recurring_application_charge_id": 654381177}
        )
        charge.save()
        self.assertEqual("1000 emails", charge.description)

    def test_get_usage_charge(self):
        self.fake(
            "recurring_application_charges/654381177/usage_charges/359376002",
            method="GET",
            body=self.load_fixture("usage_charge"),
        )

        charge = shopify.UsageCharge.find(359376002, recurring_application_charge_id=654381177)
        self.assertEqual("1000 emails", charge.description)


================================================
File: test/user_test.py
================================================
import shopify
from test.test_helper import TestCase


class UserTest(TestCase):
    def test_get_all_users(self):
        self.fake("users", body=self.load_fixture("users"))
        users = shopify.User.find()

        self.assertEqual(2, len(users))
        self.assertEqual("Steve", users[0].first_name)
        self.assertEqual("Jobs", users[0].last_name)

    def test_get_user(self):
        self.fake("users/799407056", body=self.load_fixture("user"))
        user = shopify.User.find(799407056)

        self.assertEqual("Steve", user.first_name)
        self.assertEqual("Jobs", user.last_name)

    def test_get_current_user(self):
        self.fake("users/current", body=self.load_fixture("user"))
        user = shopify.User.current()

        self.assertEqual("Steve", user.first_name)
        self.assertEqual("Jobs", user.last_name)


================================================
File: test/variant_test.py
================================================
import shopify
from test.test_helper import TestCase


class VariantTest(TestCase):
    def test_get_variants(self):
        self.fake("products/632910392/variants", method="GET", body=self.load_fixture("variants"))
        v = shopify.Variant.find(product_id=632910392)

    def test_get_variant_namespaced(self):
        self.fake("products/632910392/variants/808950810", method="GET", body=self.load_fixture("variant"))
        v = shopify.Variant.find(808950810, product_id=632910392)

    def test_update_variant_namespace(self):
        self.fake("products/632910392/variants/808950810", method="GET", body=self.load_fixture("variant"))
        v = shopify.Variant.find(808950810, product_id=632910392)

        self.fake(
            "products/632910392/variants/808950810",
            method="PUT",
            body=self.load_fixture("variant"),
            headers={"Content-type": "application/json"},
        )
        v.save()

    def test_create_variant(self):
        self.fake(
            "products/632910392/variants",
            method="POST",
            body=self.load_fixture("variant"),
            headers={"Content-type": "application/json"},
        )
        v = shopify.Variant({"product_id": 632910392})
        v.save()

    def test_create_variant_then_add_parent_id(self):
        self.fake(
            "products/632910392/variants",
            method="POST",
            body=self.load_fixture("variant"),
            headers={"Content-type": "application/json"},
        )
        v = shopify.Variant()
        v.product_id = 632910392
        v.save()

    def test_get_variant(self):
        self.fake("variants/808950810", method="GET", body=self.load_fixture("variant"))
        v = shopify.Variant.find(808950810)


================================================
File: test/fixtures/access_scopes.json
================================================
{
  "access_scopes": [
    {
      "handle": "read_products"
    },
    {
      "handle": "write_orders"
    },
    {
      "handle": "read_orders"
    }
  ]
}


================================================
File: test/fixtures/application_credit.json
================================================
{
  "application_credit": {
    "id": 445365009,
    "amount": "5.00",
    "description": "credit for application refund",
    "test": null
  }
}


================================================
File: test/fixtures/application_credits.json
================================================
{
  "application_credits": [
    {
      "id": 445365009,
      "amount": "5.00",
      "description": "credit for application refund",
      "test": null
    }
  ]
}


================================================
File: test/fixtures/article.json
================================================
{
  "article": {
    "author": "Shopify",
    "blog_id": 1008414260,
    "body_html": null,
    "created_at": "2012-07-06T13:57:28-04:00",
    "id": 6242736,
    "published_at": "2012-07-06T13:57:28-04:00",
    "summary_html": null,
    "title": "First Post",
    "updated_at": "2012-07-06T13:57:51-04:00",
    "user_id": null,
    "tags": "consequuntur, cupiditate, repellendus"
  }
}


================================================
File: test/fixtures/articles.json
================================================
{
  "articles": [{
    "author": "Shopify",
    "blog_id": 1008414260,
    "body_html": null,
    "created_at": "2012-07-06T13:57:28-04:00",
    "id": 6242736,
    "published_at": "2012-07-06T13:57:28-04:00",
    "summary_html": null,
    "title": "First Post",
    "updated_at": "2012-07-06T13:57:51-04:00",
    "user_id": null,
    "tags": "consequuntur, cupiditate, repellendus"
  }, {
    "author": "development shop",
    "blog_id": 1008414260,
    "body_html": null,
    "created_at": "2013-04-21T18:10:35-04:00",
    "id": 7739673,
    "published_at": "2013-04-21T18:10:22-04:00",
    "summary_html": null,
    "title": "My second blog post",
    "updated_at": "2013-04-21T18:10:35-04:00",
    "user_id": 2221540,
    "tags": ""
  }, {
    "author": "development shop",
    "blog_id": 1008414260,
    "body_html": null,
    "created_at": "2013-04-21T18:11:19-04:00",
    "id": 7739683,
    "published_at": "2013-04-21T18:10:45-04:00",
    "summary_html": null,
    "title": "50% off sale",
    "updated_at": "2013-04-21T18:11:19-04:00",
    "user_id": 2221540,
    "tags": ""
  }]
}


================================================
File: test/fixtures/asset.json
================================================
{
  "asset": {
    "created_at": "2010-07-12T15:31:50-04:00",
    "updated_at": "2010-07-12T15:31:50-04:00",
    "public_url": null,
    "value": "<!-- LIST 3 PER ROW -->\n<h2>Featured Products</h2>\n<table id=\"products\" cellspacing=\"0\" cellpadding=\"0\">\n{% tablerow product in collections.frontpage.products cols:3  %}\n   <a href=\"{{product.url}}\">{{ product.featured_image | product_img_url: 'small' | img_tag }}</a>\n   <h3><a href=\"{{product.url}}\">{{product.title}}</a></h3>\n   <ul class=\"attributes\">\n     <li><span class=\"money\">{{product.price_min | money}}</span></li>\n   </ul>\n{% endtablerow %}\n</table>\n<!-- /LIST 3 PER ROW  -->\n\n  <div id=\"articles\">\n  \t{% assign article = pages.frontpage %}\n\n    <div class=\"article\">\n    {% if article.content != \"\" %}\n\t\t  <h3>{{ article.title }}</h3>\n      <div class=\"article-body textile\">\n  \t\t  {{ article.content }}\n  \t\t</div>\n  \t{% else %}\n      <div class=\"article-body textile\">\n  \t  In <em>Admin &gt; Blogs &amp; Pages</em>, create a page with the handle <strong><code>frontpage</code></strong> and it will show up here.<br />\n  \t  {{ \"Learn more about handles\" | link_to \"http://wiki.shopify.com/Handle\" }}\n      </div>\n  \t{% endif %}\n    </div>\n\n  </div>\n\n",
    "key": "templates/index.liquid"
  }
}


================================================
File: test/fixtures/assets.json
================================================
{
  "assets": [
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-body-green.gif?1",
      "key": "assets/bg-body-green.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-body-orange.gif?1",
      "key": "assets/bg-body-orange.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-body-pink.gif?1",
      "key": "assets/bg-body-pink.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-body.gif?1",
      "key": "assets/bg-body.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-content.gif?1",
      "key": "assets/bg-content.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-footer.gif?1",
      "key": "assets/bg-footer.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-main.gif?1",
      "key": "assets/bg-main.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/bg-sidebar.gif?1",
      "key": "assets/bg-sidebar.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/shop.css?1",
      "key": "assets/shop.css"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/shop.css.liquid?1",
      "key": "assets/shop.css.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/shop.js?1",
      "key": "assets/shop.js"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/sidebar-devider.gif?1",
      "key": "assets/sidebar-devider.gif"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": "http://static.shopify.com/s/files/1/6909/3384/t/1/assets/sidebar-menu.jpg?1",
      "key": "assets/sidebar-menu.jpg"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "config/settings.html"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "layout/theme.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/article.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/blog.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/cart.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/collection.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/index.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/page.liquid"
    },
    {
      "created_at": "2010-07-12T15:31:50-04:00",
      "updated_at": "2010-07-12T15:31:50-04:00",
      "public_url": null,
      "key": "templates/product.liquid"
    }
  ]
}


================================================
File: test/fixtures/authors.json
================================================
{"authors": ["Shopify", "development shop", "development shop"]}


================================================
File: test/fixtures/balance.json
================================================
{
  "balance": [
    {
      "currency": "USD",
      "amount": "53.99"
    }
  ]
}


================================================
File: test/fixtures/batch_discount_codes.json
================================================
{
  "discount_codes": [
    {
      "id": null,
      "code": "foo",
      "errors": {}
    },
    {
      "id": null,
      "code": "",
      "errors": {}
    },
    {
      "id": null,
      "code": "bar",
      "errors": {}
    }
  ]
}


================================================
File: test/fixtures/blog.json
================================================
{
  "blog": {
    "handle": "test-blog",
    "created_at": "2012-01-10T17:45:19-05:00",
    "title": "Test Blog",
    "template_suffix": null,
    "updated_at": "2012-01-10T17:45:19-05:00",
    "feedburner_location": null,
    "id": 1008414260,
    "feedburner": null,
    "commentable": "no"
  }
}


================================================
File: test/fixtures/blogs.json
================================================
{
  "blogs": [{
    "handle": "test-blog",
    "created_at": "2012-01-10T17:45:19-05:00",
    "title": "Test Blog",
    "template_suffix": null,
    "updated_at": "2012-01-10T17:45:19-05:00",
    "feedburner_location": null,
    "id": 1008414260,
    "feedburner": null,
    "commentable": "no"
  }]
}


================================================
File: test/fixtures/carrier_service.json
================================================
{
  "carrier_service": {
    "name": "Some Postal Service",
    "id": 123456,
    "callback_url": "http://google.com",
    "format": "json",
    "service_discovery": true
  }
}


================================================
File: test/fixtures/carts.json
================================================
{
  "carts": [
    {
      "id": 2,
      "note": null,
      "token": "3eed8183d4281db6ea82ee2b8f23e9cc",
      "updated_at": "2012-02-13T14:39:37-05:00",
      "line_items":
      [
        {
          "id": 1,
          "title": "test",
          "price": "1.00",
          "line_price": "1.00",
          "quantity": 1,
          "sku": "",
          "grams": 1000,
          "vendor": "test",
          "variant_id": 1
        }
      ]
    },
    {
      "id": 1,
      "note": "",
      "token": "49801807939c296be1e9a4bf6783a705",
      "updated_at": "2012-02-13T14:39:12-05:00",
      "line_items":[
        {
          "id": 1,
          "title": "test",
          "price": "1.00",
          "line_price": "1.00",
          "quantity": 1,
          "sku": "",
          "grams": 1000,
          "vendor": "test",
          "variant_id": 1
        }
      ]
    }
  ]
}


================================================
File: test/fixtures/checkouts.json
================================================
{
  "checkouts": [
    {
      "buyer_accepts_marketing": false,
      "cart_token": "68778783ad298f1c80c3bafcddeea02f",
      "closed_at": null,
      "completed_at": null,
      "created_at": "2012-10-12T07:05:27-04:00",
      "currency": "USD",
      "email": "bob.norman@hostmail.com",
      "gateway": null,
      "id": 450789469,
      "landing_site": null,
      "note": null,
      "referring_site": null,
      "shipping_lines": [
        {
          "title": "Free Shipping",
          "price": "0.00",
          "code": "Free Shipping",
          "source": "shopify"
        }
      ],
      "source": null,
      "source_identifier": null,
      "source_name": "web",
      "source_url": null,
      "subtotal_price": "398.00",
      "taxes_included": false,
      "token": "2a1ace52255252df566af0faaedfbfa7",
      "total_discounts": "0.00",
      "total_line_items_price": "398.00",
      "total_price": "409.94",
      "total_tax": "11.94",
      "total_weight": 400,
      "updated_at": "2012-10-12T07:05:27-04:00",
      "line_items": [
        {
          "applied_discounts": [

          ],
          "compare_at_price": null,
          "fulfillment_service": "manual",
          "gift_card": false,
          "grams": 200,
          "id": 49148385,
          "line_price": "199.00",
          "price": "199.00",
          "product_id": 632910392,
          "properties": null,
          "quantity": 1,
          "requires_shipping": true,
          "sku": "IPOD2008RED",
          "tax_lines": [

          ],
          "taxable": true,
          "title": "IPod Nano - 8GB",
          "variant_id": 49148385,
          "variant_title": "Red",
          "vendor": "Apple"
        },
        {
          "applied_discounts": [

          ],
          "compare_at_price": null,
          "fulfillment_service": "manual",
          "gift_card": false,
          "grams": 200,
          "id": 808950810,
          "line_price": "199.00",
          "price": "199.00",
          "product_id": 632910392,
          "properties": null,
          "quantity": 1,
          "requires_shipping": true,
          "sku": "IPOD2008PINK",
          "tax_lines": [

          ],
          "taxable": true,
          "title": "IPod Nano - 8GB",
          "variant_id": 808950810,
          "variant_title": "Pink",
          "vendor": "Apple"
        }
      ],
      "name": "#450789469",
      "note_attributes": [
        {
          "name": "custom engraving",
          "value": "Happy Birthday"
        },
        {
          "name": "colour",
          "value": "green"
        }
      ],
      "discount_codes": [
        {
          "code": "TENOFF",
          "amount": "10.00"
        }
      ],
      "abandoned_checkout_url": "https://checkout.local/orders/690933842/2a1ace52255252df566af0faaedfbfa7?recovered=1",
      "tax_lines": [
        {
          "price": "11.94",
          "rate": 0.06,
          "title": "State Tax"
        }
      ],
      "billing_address": {
        "address1": "Chestnut Street 92",
        "address2": "",
        "city": "Louisville",
        "company": null,
        "country": "United States",
        "first_name": "Bob",
        "last_name": "Norman",
        "latitude": "45.41634",
        "longitude": "-75.6868",
        "phone": "555-625-1199",
        "province": "Kentucky",
        "zip": "40202",
        "name": "Bob Norman",
        "country_code": "US",
        "province_code": "KY"
      },
      "shipping_address": {
        "address1": "Chestnut Street 92",
        "address2": "",
        "city": "Louisville",
        "company": null,
        "country": "United States",
        "first_name": "Bob",
        "last_name": "Norman",
        "latitude": "45.41634",
        "longitude": "-75.6868",
        "phone": "555-625-1199",
        "province": "Kentucky",
        "zip": "40202",
        "name": "Bob Norman",
        "country_code": "US",
        "province_code": "KY"
      },
      "customer": {
        "accepts_marketing": false,
        "created_at": "2014-03-07T16:12:37-05:00",
        "email": "bob.norman@hostmail.com",
        "first_name": "Bob",
        "id": 207119551,
        "last_name": "Norman",
        "last_order_id": null,
        "multipass_identifier": null,
        "note": null,
        "orders_count": 0,
        "state": "disabled",
        "total_spent": "0.00",
        "updated_at": "2014-03-07T16:12:37-05:00",
        "verified_email": true,
        "tags": "",
        "last_order_name": null,
        "default_address": {
          "address1": "Chestnut Street 92",
          "address2": "",
          "city": "Louisville",
          "company": null,
          "country": "United States",
          "first_name": null,
          "id": 207119551,
          "last_name": null,
          "phone": "555-625-1199",
          "province": "Kentucky",
          "zip": "40202",
          "name": null,
          "province_code": "KY",
          "country_code": "US",
          "country_name": "United States",
          "default": true
        }
      }
    }
  ]
}


================================================
File: test/fixtures/collection_listing.json
================================================
{
  "collection_id": 1,
  "updated_at": "2017-01-09T13:59:09-05:00",
  "body_html": null,
  "default_product_image": null,
  "handle": "frontpage",
  "image": null,
  "title": "Home page",
  "sort_order": "alpha-asc",
  "published_at": "2017-01-09T13:59:09-05:00"
}


================================================
File: test/fixtures/collection_listing_product_ids.json
================================================
[
  1,
  2
]


================================================
File: test/fixtures/collection_listings.json
================================================
[
  {
    "collection_id": 1,
    "updated_at": "2017-01-09T13:59:09-05:00",
    "body_html": null,
    "default_product_image": null,
    "handle": "frontpage",
    "image": null,
    "title": "Home page",
    "sort_order": "alpha-asc",
    "published_at": "2017-01-09T13:59:09-05:00"
  }
]


================================================
File: test/fixtures/collection_publication.json
================================================
{
  "collection_publication": {
    "id": 96062799894,
    "publication_id": 55650051,
    "published_at": "2018-09-05T17:22:31-04:00",
    "published": true,
    "created_at": "2018-09-05T17:22:31-04:00",
    "updated_at": "2018-09-14T14:31:19-04:00",
    "collection_id": 60941828118
  }
}


================================================
File: test/fixtures/collection_publications.json
================================================
{
  "collection_publications": [
    {
        "id": 96062799894,
        "publication_id": 55650051,
        "published_at": "2018-09-05T17:22:31-04:00",
        "published": true,
        "created_at": "2018-09-05T17:22:31-04:00",
        "updated_at": "2018-09-14T14:31:19-04:00",
        "collection_id": 60941828118
    }
  ]
}


================================================
File: test/fixtures/currencies.json
================================================
{
  "currencies": [
    {
        "currency": "AUD",
        "rate_updated_at": "2018-10-03T14:44:08-04:00",
        "enabled": true
    },
    {
        "currency": "EUR",
        "rate_updated_at": "2018-10-03T14:44:08-04:00",
        "enabled": true
    },
    {
        "currency": "GBP",
        "rate_updated_at": "2018-10-03T14:44:08-04:00",
        "enabled": true
    },
    {
        "currency": "HKD",
        "rate_updated_at": "2018-10-03T14:44:08-04:00",
        "enabled": false
    }
  ]
}


================================================
File: test/fixtures/customer.json
================================================
{
  "customer": {
    "accepts_marketing": false,
    "created_at": "2015-05-27T18:11:24-04:00",
    "email": "bob.norman@hostmail.com",
    "first_name": "Bob",
    "id": 207119551,
    "last_name": "Norman",
    "last_order_id": 450789469,
    "multipass_identifier": null,
    "note": null,
    "orders_count": 1,
    "state": "disabled",
    "tax_exempt": false,
    "total_spent": "41.94",
    "updated_at": "201